#pragma config(Sensor, in1,    SKYRISESWITCH,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  CLAW,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  LiftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  LiftLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  DriveLeft,      sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  DriveRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl10, StrafeEncoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl12, AUTOCHANGE,     sensorTouch)
#pragma config(Motor,  port1,           StrafeWheel2,  tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port2,           LeftRear,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           LeftFront,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           RightRear,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           RightFront,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           LeftBottom,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           RightTop,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           LeftTop,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           RightBottom,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          StrafeWheel,   tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void clearencoders();
void strafe(float speed);
void lift(float speed);
void driveSpeedleft(float speed);
void driveSpeedright(float speed);
void pidDrivecontrol(float destinationAngle, int range1, int range2,int directionRightside, int directionLeftside, int Precision);
void liftSpeedleft(float speed);
void liftSpeedright(float speed);
void pidLiftcontrol(float destinationAngle, int range1, int range2, int directionRightside, int directionLeftside, int Precision);
void blueCubeautonomous();
void redCubeautonomous();
void blueSkyriseautonomous();
void redSkyriseautonomous();
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

// PID using optical shaft encoder
//
// Shaft encoder has 360 pulses per revolution
//
#define PID_SENSOR_INDEX     DriveLeft
#define PID_SENSOR_INDEX1    LiftRight
#define PID_SENSOR_SCALE    (1)


#define PID_MOTOR_SCALE     (-1)


#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)

#define PID_INTEGRAL_LIMIT  40

// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float  pid_Kp = 0.70;
float  pid_Ki = 0.02;
float  pid_Kd = 0.06;

static int   pidRunning = 1;

/////////////////////////////////////////
//Starts PID drive control functions
//mind that PID_SENSOR_INDEX is the drive left encoder









/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
////                                Task Autonmous
////
////
////
////
//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
static int red=0;
static int blue=1;
static float skyriseLimit=2047.5;

task autonomous()
{
	if (SensorValue[AUTOCHANGE]==blue && SensorValue[SKYRISESWITCH]<skyriseLimit)//changes autonomous to blue
	{
		blueCubeautonomous();
	}


	if (SensorValue[AUTOCHANGE]==red && SensorValue[SKYRISESWITCH]<skyriseLimit )//changes autonomous to red
	{	//Clear Encoders
		redCubeautonomous();
	}

	if (SensorValue[AUTOCHANGE]==blue && SensorValue[SKYRISESWITCH]>skyriseLimit)//changes autonomous to blue
	{
		blueSkyriseautonomous();
	}


	if (SensorValue[AUTOCHANGE]==red && SensorValue[SKYRISESWITCH]>skyriseLimit )//changes autonomous to red
	{	//Clear Encoders
		redSkyriseautonomous();
	}



}


task strafeButtoncontrol()
{

	//The following controls the strafe wheel
	if(vexRT[Btn8R] == 1)
	{
		strafe(127);
	}

	else if(vexRT[Btn8L] == 1)//Btn 8l goes left
	{
		strafe(-127);
	}
	else
	{
		strafe(0);
	}
}

task strafeTiltcontrol()						//TILT code
{
	int STRFthreshold=36;				//Threshold value obtained empirically. 36 works best


	if((vexRT[AccelX] < (-1 * STRFthreshold))) //controller tilted LEFT beyond threshold (NEGATIVE value)
	{
		strafe(-127);		//LEFT
	}
	else if((vexRT[AccelX] > (STRFthreshold))) //controller tilted RIGHT beyond threshold (POSITIVE value)
	{
		strafe(127);			//RIGHT
	}
	else
	{
		strafe(0);
	}
}

//Strafe toggle---------------------------------------------------------------------------------------
//Control variable "toggle" = true/false- TRUE = tilt; FALSE = button
//																	//Toggle controlled by btn7R
bool toggle= false;
task STRFControl()
{

	//TOGGLE CONTROL STRUCTURE
	while(1==1)
	{
		if(vexRT[btn7R] == 1)
		{
			toggle = true;								//set true

			waitInMilliseconds(300);			//Wait to prevent instananeous oscillation
		}
		if(vexRT[btn7D] == 1)
		{
			toggle = false;								//set  false

			waitInMilliseconds(300);			//Wait to prevent instananeous oscillation
		}
	}
}



task STRFCode()
{
	while(1==1)
	{
		if(toggle == true)
		{
			startTask (strafeTiltcontrol);
			stopTask (strafeButtoncontrol);
		}
		if(toggle == false)
		{
			startTask (strafeButtoncontrol);
			stopTask (strafeTiltcontrol);
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


/*

#define PIDL_SENSOR_INDEX    LiftLeft				//Lift encoder
#define PIDL_SENSOR_SCALE    (1)

void LPID (float LPIDSpeed)
{
motor[LeftTop] = LPIDSpeed;
motor[LeftBottom] = LPIDSpeed;
motor[RightTop] = LPIDSpeed;
motor[RightBottom] = LPIDSpeed;
}

#define PIDL_MOTOR_SCALE     (-1)					// -1 necessary to ensure exponential decay and not growth

#define PIDL_SPEED_MAX       127						//Minimum and maximum motor speeds
#define PIDL_SPEED_MIN     (-127)

static float pidTargetL;		//Target value

static int	T_TargetL = 10;								// Target value calculation refreshes per 10 ms
static int	T_SpeedL = 5;									// Speed calculation refreshes per 5 ms

task liftPID()
{
float  pidLSensorCurrentValue;
float  pidLError;
float  pidLLastError;
float  pidLIntegral;
float  pidLDerivative;
float  pidLSpeed;

// Init the variables - thanks Glenn :)
pidLLastError  = 0;
pidLIntegral   = 0;

while( true )
{
// Read the sensor value and scale
pidLSensorCurrentValue = (SensorValue[ PIDL_SENSOR_INDEX ] * PIDL_SENSOR_SCALE);

// calculate error
pidLError = pidLSensorCurrentValue - pidTargetL;

// integral - if Ki is not 0
if( pid_Ki != 0 )
{
// If we are inside controlable window then integrate the error
if( abs(pidLError) < PID_INTEGRAL_LIMIT )
pidLIntegral = pidLIntegral + pidLError;
else
pidLIntegral = 0;
}
else
pidLIntegral = 0;

// calculate the derivative
pidLDerivative = pidLError - pidLLastError;
pidLLastError  = pidLError;

// calculate drive
pidLSpeed = (pid_Kp * pidLError) + (pid_Ki * pidLIntegral) + (pid_Kd * pidLDerivative);

// limit drive
if( pidLSpeed > PIDL_SPEED_MAX )
{
pidLSpeed = PIDL_SPEED_MAX;
}
if( pidLSpeed < PIDL_SPEED_MIN )
{
pidLSpeed = PIDL_SPEED_MIN;
}

// send to motor
LPID((pidLSpeed * PIDL_MOTOR_SCALE));

wait1Msec( T_SpeedL );					//Wait 5 ms to refresh this calculation = 200 Hz
}
}

*/




task usercontrol()
{
	// This ca	lls the functions, outside of the while loop to operate the toggle and tilt/button strafe
	startTask (STRFCode);
	startTask (STRFControl);

	/*
	startTask (liftPID);

	pidTargetL = 0;
	*/

	while(true)
	{
		clearencoders();



		/*

		float deltaTarget = 0.6;

		// use buttons to modify the requested position
		while( 1==1 )
		{
		// current dTarget/dt is 0.6 countE / 10 ms = 60 countE/s

		if((vexRT[Btn5U] == 1))
		{
		pidTargetL = ceil (pidTargetL + (deltaTarget));
		}
		if((vexRT[Btn5D] == 1))
		{
		pidTargetL = floor (pidTargetL - (deltaTarget));
		}

		wait1Msec( T_TargetL );					//Wait 10 ms to refresh = 100 s^-1 , or 1500 countP / s

		*/



		//Right side of the robot is controlled by the right joystick, Y-axis

		driveSpeedright(vexRT[Ch2]);
		//Left side of the robot is controlled by the left joystick, Y-axis

		driveSpeedleft(vexRT[Ch3]);





		//The following will control lift


		if(vexRT[Btn5U] == 1)
		{
			lift(127);
		}
		else if(vexRT[Btn5D] == 1)//Btn 5D goes down
		{
			lift(-127);
		}
		else
		{
			lift(0);
		}







		//This controls the pneuamtic CLAW.
		if(vexRT[Btn6U] == 1)         // If button 6U (upper right shoulder button) is pressed:
		{
			SensorValue[CLAW] = 1;
			SensorValue[CLAW] = 1;		// ...activate the solenoid.
		}
		else                          // If button 6U (upper right shoulder button) is  NOT pressed:
		{
			SensorValue[CLAW] = 0;  // ..deactivate the solenoid.
			SensorValue[CLAW] = 0;
		}

		//---------------------------------------------------------------------------------------------------------------------------------------------
		/*
		//The following is for the motor CLAW
		if(vexRT[Btn6U] == 1)       	//If Button 6U is pressed...
		{
		motor[CLAWMotor] = 127;  		//...close the gripper.
		}
		else if(vexRT[Btn6D] == 1)  	//Else, if button 6D is pressed...
		{
		motor[CLAWMotor] = -127; 		//...open the gripper.
		}
		else                      		//Else (neither button is pressed)...
		{
		motor[CLAWMotor] = 0;    		//...stop the gripper.
		}
		*/
	}
}



/*task autonomous()
{
if (SensorValue[AUTOCHANGE]==1)//changes autonomous to blue
{	//Clear Encoders
SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

waitInMilliseconds(500);

//closes claw
SensorValue[CLAW] = 1;



//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127)  ;

//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127) ;
startMotor(LeftRear,-127) ;

untilEncoderCounts(720, dgtl6);//backwards for 2 turns

stopMotor(RightFront);//kills drive motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);




//autonomous lift


startMotor(LeftBottom,127) ;//Lift goes up
startMotor(RightBottom,127);
startMotor(LeftTop,127) ;
startMotor(RightTop,127) ;

untilEncoderCounts(450, dgtl2);//goes up until encoder reaches 450 degrees

stopMotor(LeftBottom);//stops lift
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//--------------------------------------------------



//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;

//Left side of the robot is foward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(400, dgtl6);// the motors will continue to force the robot to go forward until the wheels hve turned <1 full rotation


stopMotor(RightFront);//this stops all the motors from moving
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(200, dgtl2);//contines to go down until the encoder reads 200 degrees. Its initial state was 450 degrees



stopMotor(LeftBottom);//Then the lift motors will turn off
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);


waitInMilliseconds(250);//To ensure stability a wait time has been placed

SensorValue[CLAW] = 0;//The claw releases

waitInMilliseconds(250);

//Right side of the robot is backward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(-360, dgtl6);//The robot should reverse 360 degrees----- If this does not work use  waitInMilliseconds(800);



stopMotor(RightFront);//stops all motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(100);
//------------------------------------------------------------------------------

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(-250, dgtl2);//it was dificult to get the encoder value to actually work so... we used a timer--- should be untilEncoderCounts(0, dgtl2);

stopMotor(LeftBottom);//stops the lift motors
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//-----------------------------------------------------------------------------------------------------


//clears the sensor values to make programming easier

SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

//Right side of the robot is forward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-180,dgtl6);//turns left about 50 degrees--- was positive

stopMotor(RightFront); //kills the turn
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);


//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-160, dgtl6);//robot moves forward until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);

SensorValue[CLAW] = 1;//closes claw around the cube on the left

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is Backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(120, dgtl6);//robot moves backwards until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);

//Right side of the robot is backward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is foward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(220, dgtl6);//turns right to swing the cube into the floor goals---- was negative

stopMotor(RightFront); //kills the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);
waitInMilliseconds(250);
//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-120, dgtl6);//robot moves forward until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);




waitInMilliseconds(250);

SensorValue[CLAW] = 0;//Releases claw

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(540, dgtl6);//backwards for a few turns -----   we had a 1000 milisecond timer: LAZY CODING-- Just to get the robot away from the scored cube

stopMotor(RightFront);//kills motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

}



//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//This is for red side

if (SensorValue[AUTOCHANGE]==0)//changes autonomous to red
{
//clears encoders
SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

waitInMilliseconds(500);

//closes claw
SensorValue[CLAW] = 1;



//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127)  ;

//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127) ;
startMotor(LeftRear,-127) ;

untilEncoderCounts(720, dgtl6);//backwards for 2 turns

stopMotor(RightFront);//kills drive motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);




//autonomous lift


startMotor(LeftBottom,127) ;//Lift goes up
startMotor(RightBottom,127);
startMotor(LeftTop,127) ;
startMotor(RightTop,127) ;

untilEncoderCounts(450, dgtl2);//goes up until encoder reaches 450 degrees

stopMotor(LeftBottom);//stops lift
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//--------------------------------------------------



//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;

//Left side of the robot is foward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(360, dgtl6);// the motors will continue to force the robot to go forward until the wheels hve turned 1 full rotation


stopMotor(RightFront);//this stops all the motors from moving
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(200, dgtl2);//contines to go down until the encoder reads 200 degrees. Its initial state was 450 degrees



stopMotor(LeftBottom);//Then the lift motors will turn off
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);


waitInMilliseconds(250);//To ensure stability a wait time has been placed

SensorValue[CLAW] = 0;//The claw releases

waitInMilliseconds(250);

//Right side of the robot is backward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(-360, dgtl6);//The robot should reverse 360 degrees----- If this does not work use  waitInMilliseconds(800);



stopMotor(RightFront);//stops all motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(100);
//------------------------------------------------------------------------------

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(-250, dgtl2);//it was dificult to get the encoder value to actually work so... we used a timer--- should be untilEncoderCounts(0, dgtl2);

stopMotor(LeftBottom);//stops the lift motors
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//-----------------------------------------------------------------------------------------------------


//clears the sensor values to make programming easier

SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(180,dgtl6);//turns left about 50 degrees--- was positive

stopMotor(RightFront); //kills the turn
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);


//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(160, dgtl6);//robot moves forward until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);

SensorValue[CLAW] = 1;//closes claw around the cube on the left

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is Backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(120, dgtl6);//robot moves backwards until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);
//Right side of the robot is backward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is foward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(220, dgtl6);//turns right to swing the cube into the floor goals---- was negative

stopMotor(RightFront); //kills the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);
//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-120, dgtl6);//robot moves forward until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);
waitInMilliseconds(250);

SensorValue[CLAW] = 0;//Releases claw

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(540, dgtl6);//backwards for a few turns -----   we had a 1000 milisecond timer: LAZY CODING-- Just to get the robot away from the scored cube

stopMotor(RightFront);//kills motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);
}



}
*/
void liftSpeedleft(float speed)
{
	motor[LeftBottom]=speed;
	motor[LeftTop]=speed;

}
void liftSpeedright(float speed)
{

	motor[RightBottom]=speed;
	motor[RightTop]=speed;
}

void strafe(float speed)
{
	motor[StrafeWheel] = speed;
	motor[StrafeWheel2] = speed;
}

void lift(float speed)
{
	motor[LeftBottom] = speed;
	motor[RightBottom] = speed;
	motor[LeftTop] = speed;
	motor[RightTop] = speed;
}
void driveSpeedleft(float speed)
{
	motor[LeftRear]=speed;
	motor[LeftFront]=speed;

}
void driveSpeedright(float speed)
{

	motor[RightRear]=speed;
	motor[RightFront]=speed;
}


/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid Drive control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
void pidDrivecontrol(float destinationAngle, int range1, int range2,int directionRightside, int directionLeftside, int Precision)
{
	float  pidSensorCurrentValue;
	int count=0;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEX ] == sensorQuadEncoder )
		SensorValue[ PID_SENSOR_INDEX ] = 0;

	// Init the variables
	pidLastError  = 0;
	pidIntegral   = 0;

	while( count!= Precision )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = SensorValue[ PID_SENSOR_INDEX ] * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - destinationAngle;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidDrive > PID_DRIVE_MAX )
				pidDrive = PID_DRIVE_MAX;
			if( pidDrive < PID_DRIVE_MIN )
				pidDrive = PID_DRIVE_MIN;

			// send to motor
			driveSpeedleft(pidDrive * PID_MOTOR_SCALE * directionLeftside);
			driveSpeedright(pidDrive * PID_MOTOR_SCALE * directionRightside);
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			driveSpeedleft(0);
			driveSpeedright(0);
		}
		if (SensorValue[PID_SENSOR_INDEX]>range1 && SensorValue[PID_SENSOR_INDEX]<range2 )
		{
			count++;
		}

		// Run at 50Hz
		wait1Msec( 10 );
	}
}
//////////////////////////////////////////////////////////////////////////////
//function for lifts
//mind that PID_SENSOR_INDEX1 is the lift encoder




/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid Lift control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

void pidLiftcontrol(float destinationAngle, int range1, int range2, int directionRightside, int directionLeftside, int Precision)
{
	float  pidSensorCurrentValue;
	int count=0;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEX1 ] == sensorQuadEncoder )
		SensorValue[ PID_SENSOR_INDEX1 ] = 0;

	// Init the variables - thanks Glenn :)
	pidLastError  = 0;
	pidIntegral   = 0;

	while( count!= Precision)
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = SensorValue[ PID_SENSOR_INDEX1 ] * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - destinationAngle;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidDrive > PID_DRIVE_MAX )
				pidDrive = PID_DRIVE_MAX;
			if( pidDrive < PID_DRIVE_MIN )
				pidDrive = PID_DRIVE_MIN;

			// send to motor
			liftSpeedleft(pidDrive * PID_MOTOR_SCALE * directionLeftside);
			liftSpeedright(pidDrive * PID_MOTOR_SCALE * directionRightside);
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			liftSpeedleft(0);
			liftSpeedright(0);
		}
		if (SensorValue[PID_SENSOR_INDEX1]>range1 && SensorValue[PID_SENSOR_INDEX1]<range2 )
		{
			count++;
		}
		// Run at 50Hz
		wait1Msec( 25 );
	}
}
void clearencoders()
{
	SensorValue[DriveLeft] = 0;
	SensorValue[DriveRight] = 0;
	SensorValue[LiftLeft] = 0;
	SensorValue[LiftRight] = 0;

}
//blue autonomous for cubes function
void redCubeautonomous()
{
	clearencoders();


	SensorValue[CLAW] = 1;//closes claw on preload

	pidDrivecontrol(-720,-725,-715,1,1,2);//brings the drive back to -720 degrees or moves the robot back two turns

	wait1Msec( 100);//waits .1 second before executing the lift function

	pidLiftcontrol(-450,-460,-440,-1,-1,1);//

	wait1Msec( 200);//waits .2 second before executing the drive forward function

	pidDrivecontrol(210,205,220,1,1,2);

	wait1Msec( 200);//waits .2 second before executing the lift function

	pidLiftcontrol(290,280,300,-1,-1,1);//puts cube on the pole

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-360,-365,-355,1,1,2);//brings the drive back to -360 degrees or moves the robot back one turn

	wait1Msec( 150);//waits .15 second before executing

	pidLiftcontrol(30,20,40,-1,-1,1);//lowers the lift

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(240,235,245,-1,1,1);//turns right

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 1;

	wait1Msec( 500);//waits .5 second before executing
	pidDrivecontrol(-250,-255,-245,1,1,2); //backs up

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-300,-305,-295,-1,1,2);//turns left

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(360,355,365,1,1,2);//drives forward

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;// drops cube in colored square

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-720,-725,-715,1,1,2);//brings the drive back to -720 degrees or moves the robot back two turns
}
//red autonomous for cubes function
void blueCubeautonomous()
{
	clearencoders();


	SensorValue[CLAW] = 1;//closes claw on preload

	pidDrivecontrol(-720,-725,-715,1,1,2);//brings the drive back to -720 degrees or moves the robot back two turns

	wait1Msec( 100);//waits .1 second before executing the lift function

	pidLiftcontrol(-450,-460,-440,-1,-1,1);//

	wait1Msec( 200);//waits .2 second before executing the drive forward function

	pidDrivecontrol(210,200,220,1,1,2);

	wait1Msec( 200);//waits .2 second before executing the lift function

	pidLiftcontrol(290,280,300,-1,-1,1);//puts cube on the pole

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-360,-365,-355,1,1,2);//brings the drive back to -360 degrees or moves the robot back one turn

	wait1Msec( 150);//waits .15 second before executing

	pidLiftcontrol(30,20,40,-1,-1,1);//lowers the lift

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-300,-305,-295,-1,1,2);//turns left

	wait1Msec( 150);//waits 1.5 second before executing

	SensorValue[CLAW] = 1;
	wait1Msec( 500);//waits .5 second before executing
	pidDrivecontrol(-250,-255,-245,1,1,2); //backs up

	wait1Msec( 150);//waits 1.5 second before executing

	pidDrivecontrol(220,215,225,-1,1,2);//turns right

	wait1Msec( 150);//waits 1.5 second before executing

	pidDrivecontrol(360,355,365,1,1,2);//drives forward

	wait1Msec( 150);//waits 1.5 second before executing

	SensorValue[CLAW] = 0;// drops cube in colored square

	wait1Msec( 150);//waits 1.5 second before executing

	pidDrivecontrol(-720,-725,-715,1,1,2);//brings the drive back to -720 degrees or moves the robot back two turns
}
//blue autonomous for skyrise function
void blueSkyriseautonomous()
{ //-1458.51243217 degrees will position the robot exactly 1.5 squares -- diagonal-- from the skyrise autoloader
	//the diameter of the wheen is 4pi inches. The squares are apporx 23.41 inches^2 in area.
	clearencoders();

	pidDrivecontrol(-1000,-1010,-990,1,1,4);//brings the drive back to -720 degrees or moves the robot back two turns

	pidLiftcontrol(-400,-410,-390,-1,-1,2);//should lift the lift to the autoloaders height----- must perfect the height value via trial and error calculations

	SensorValue[CLAW] = 1;//closes claw on skyrise

	waitInMilliseconds(150);//waits .15 seconds before executing

	pidDrivecontrol(-360,-365,-355,1,1,2);//brings the drive back to -360 degrees or moves the robot back one turn

	pidDrivecontrol(240,235,245,-1,1,3);//turns right

	pidLiftcontrol(290,280,300,-1,-1,1);//lowers lift to score skyrise

	SensorValue[CLAW] = 0;//releases claw

}


//blue autonomous for skyrise function
void redSkyriseautonomous()
{
	clearencoders();

	pidDrivecontrol(-1000,-1010,-990,1,1,4);//brings the drive back to -720 degrees or moves the robot back two turns

	pidLiftcontrol(-400,-410,-390,-1,-1,2);//should lift the lift to the autoloaders height----- must perfect the height value via trial and error calculations

	SensorValue[CLAW] = 1;//closes claw on skyrise

	waitInMilliseconds(150);//waits .15 seconds before executing

	pidDrivecontrol(-360,-365,-355,1,1,3);//brings the drive back to -360 degrees or moves the robot back one turn
	waitInMilliseconds(150);//waits .15 seconds before executing

	pidDrivecontrol(-240,-245,-235,-1,1,3);//turns left
	waitInMilliseconds(150);//waits .15 seconds before executing

	pidLiftcontrol(320,315,325,-1,-1,2);//lowers lift to score skyrise

	SensorValue[CLAW] = 0;//releases claw
}
