#pragma config(Sensor, in1,    SKYRISESWITCH,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  CLAW,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  LiftRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  LiftLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  DriveLeft,      sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  DriveRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl10, StrafeEncoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl12, AUTOCHANGE,     sensorTouch)
#pragma config(Motor,  port1,           StrafeWheel2,  tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port2,           LeftRear,      tmotorServoContinuousRotation, openLoop, reversed, driveLeft, encoderPort, dgtl6)
#pragma config(Motor,  port3,           LeftFront,     tmotorServoContinuousRotation, openLoop, reversed, driveLeft, encoderPort, dgtl6)
#pragma config(Motor,  port4,           RightRear,     tmotorServoContinuousRotation, openLoop, driveRight, encoderPort, dgtl8)
#pragma config(Motor,  port5,           RightFront,    tmotorServoContinuousRotation, openLoop, driveRight, encoderPort, dgtl8)
#pragma config(Motor,  port6,           LeftBottom,    tmotorServoContinuousRotation, openLoop, reversed, encoderPort, dgtl4)
#pragma config(Motor,  port7,           RightTop,      tmotorServoContinuousRotation, openLoop, encoderPort, dgtl2)
#pragma config(Motor,  port8,           LeftTop,       tmotorServoContinuousRotation, openLoop, reversed, encoderPort, dgtl4)
#pragma config(Motor,  port9,           RightBottom,   tmotorServoContinuousRotation, openLoop, encoderPort, dgtl2)
#pragma config(Motor,  port10,          StrafeWheel,   tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
#define PID_SENSOR_INDEX     DriveLeft
#define PID_SENSOR_INDEX1    LiftRight
#define PID_SENSOR_SCALE    (1)
#define PID_MOTOR_SCALE     (-1)
#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)
#define PID_INTEGRAL_LIMIT  40
float  pid_Kp = 0.70;
float  pid_Ki = 0.02;
float  pid_Kd = 0.06;
static int   pidRunning = 1;
static int red=0;
static int blue=1;
static float skyriseLimit=2047.5;
//bool toggle= false;
void clearencoders();
void strafe(float speed);
void lift(float speed);
void driveSpeedleft(float speed);
void driveSpeedright(float speed);
void pidDrivecontrol(float destinationAngle, int range1, int range2,int directionRightside, int directionLeftside, int Precision);
void liftSpeedleft(float speed);
void liftSpeedright(float speed);
void pidLiftcontrol(float destinationAngle, int range1, int range2, int directionRightside, int directionLeftside, int Precision);
void blueCubeautonomous();
void redCubeautonomous();
void blueSkyriseautonomous();
void redSkyriseautonomous();
task strafeButtoncontrol();
task strafeTiltcontrol();
//task STRFCode();
task STRFControl();
task postheights();
task tiltDrive();

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	if (SensorValue[AUTOCHANGE]==blue && SensorValue[SKYRISESWITCH]<skyriseLimit)//changes autonomous to blue
	{
		blueCubeautonomous();
	}


	if (SensorValue[AUTOCHANGE]==red && SensorValue[SKYRISESWITCH]<skyriseLimit )//changes autonomous to red
	{	//Clear Encoders
		redCubeautonomous();
	}

	if (SensorValue[AUTOCHANGE]==blue && SensorValue[SKYRISESWITCH]>skyriseLimit)//changes autonomous to blue
	{
		blueSkyriseautonomous();
	}


	if (SensorValue[AUTOCHANGE]==red && SensorValue[SKYRISESWITCH]>skyriseLimit )//changes autonomous to red
	{	//Clear Encoders
		redSkyriseautonomous();
	}



}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// This calls the tasks, outside of the while loop to operate the toggle and tilt/button strafe

	clearencoders();
	startTask (tiltDrive);
	startTask (postheights);
	//startTask (STRFCode);
	startTask (STRFControl);
	while(true)
	{


		//Right side of the robot is controlled by the right joystick, Y-axis

		driveSpeedright(vexRT[Ch2]);
		//Left side of the robot is controlled by the left joystick, Y-axis

		driveSpeedleft(vexRT[Ch3]);
		//The following will control lift

		if(vexRT[Btn5U] == 1)
		{
			lift(127);
		}
		else if(vexRT[Btn5D] == 1)//Btn 5D goes down
		{
			lift(-127);
		}
		else
		{
			lift(0);
		}

		//This controls the pneuamtic CLAW.
		if(vexRT[Btn6U] == 1)         // If button 6U (upper right shoulder button) is pressed:
		{
			SensorValue[CLAW] = 1;
			SensorValue[CLAW] = 1;		// ...activate the solenoid.
		}
		else                          // If button 6U (upper right shoulder button) is  NOT pressed:
		{
			SensorValue[CLAW] = 0;  // ..deactivate the solenoid.
			SensorValue[CLAW] = 0;
		}
		/*
		//The following is for the motor CLAW
		if(vexRT[Btn6U] == 1)       	//If Button 6U is pressed...
		{
		motor[CLAWMotor] = 127;  		//...close the gripper.
		}
		else if(vexRT[Btn6D] == 1)  	//Else, if button 6D is pressed...
		{
		motor[CLAWMotor] = -127; 		//...open the gripper.
		}
		else                      		//Else (neither button is pressed)...
		{
		motor[CLAWMotor] = 0;    		//...stop the gripper.
		}
		*/
	}
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                        Definitions and Functions/Task Repository
//
// Inculdes all autonomous references and PID control. Also includes driver control functions.
//
//
/////////////////////////////////////////////////////////////////////////////////////////


void liftSpeedleft(float speed)
{
	motor[LeftBottom]=speed;
	motor[LeftTop]=speed;

}

void liftSpeedright(float speed)
{

	motor[RightBottom]=speed;
	motor[RightTop]=speed;
}

void strafe(float speed)
{
	motor[StrafeWheel] = speed;
	motor[StrafeWheel2] = speed;
}

void lift(float speed)
{
	motor[LeftBottom] = speed;
	motor[RightBottom] = speed;
	motor[LeftTop] = speed;
	motor[RightTop] = speed;
}
void driveSpeedleft(float speed)
{
	motor[LeftRear]=speed;
	motor[LeftFront]=speed;

}
void driveSpeedright(float speed)
{

	motor[RightRear]=speed;
	motor[RightFront]=speed;

}


void pidDrivecontrol(float destinationAngle, int range1, int range2,int directionRightside, int directionLeftside, int Precision)
{
	float  pidSensorCurrentValue;
	int count=0;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEX ] == sensorQuadEncoder )
		SensorValue[ PID_SENSOR_INDEX ] = 0;

	// Init the variables - thanks Glenn :)
	pidLastError  = 0;
	pidIntegral   = 0;

	while( count!= Precision )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = SensorValue[ PID_SENSOR_INDEX ] * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - destinationAngle;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidDrive > PID_DRIVE_MAX )
				pidDrive = PID_DRIVE_MAX;
			if( pidDrive < PID_DRIVE_MIN )
				pidDrive = PID_DRIVE_MIN;

			// send to motor
			driveSpeedleft(pidDrive * PID_MOTOR_SCALE * directionLeftside);
			driveSpeedright(pidDrive * PID_MOTOR_SCALE * directionRightside);
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			driveSpeedleft(0);
			driveSpeedright(0);
		}
		if (SensorValue[PID_SENSOR_INDEX]>range1 && SensorValue[PID_SENSOR_INDEX]<range2 )
		{
			count++;
		}

		// Run at 50Hz
		wait1Msec( 10 );
	}
}
//////////////////////////////////////////////////////////////////////////////
//function for lifts
//mind that PID_SENSOR_INDEX1 is the lift encoder




/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid Lift control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

void pidLiftcontrol(float destinationAngle, int range1, int range2, int directionRightside, int directionLeftside, int Precision)
{
	float  pidSensorCurrentValue;
	int count=0;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;

	// If we are using an encoder then clear it
	if( SensorType[ PID_SENSOR_INDEX1 ] == sensorQuadEncoder )
		SensorValue[ PID_SENSOR_INDEX1 ] = 0;

	// Init the variables - thanks Glenn :)
	pidLastError  = 0;
	pidIntegral   = 0;

	while( count!= Precision)
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = SensorValue[ PID_SENSOR_INDEX1 ] * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - destinationAngle;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidDrive > PID_DRIVE_MAX )
				pidDrive = PID_DRIVE_MAX;
			if( pidDrive < PID_DRIVE_MIN )
				pidDrive = PID_DRIVE_MIN;

			// send to motor
			liftSpeedleft(pidDrive * PID_MOTOR_SCALE * directionLeftside);
			liftSpeedright(pidDrive * PID_MOTOR_SCALE * directionRightside);
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			liftSpeedleft(0);
			liftSpeedright(0);
		}
		if (SensorValue[PID_SENSOR_INDEX1]>range1 && SensorValue[PID_SENSOR_INDEX1]<range2 )
		{
			count++;
		}
		// Run at 50Hz
		wait1Msec( 25 );
	}
}

void clearencoders()//function created to clear motor encoders
{
	SensorValue[DriveLeft] = 0;
	SensorValue[DriveRight] = 0;
	SensorValue[LiftLeft] = 0;
	SensorValue[LiftRight] = 0;


}
//blue autonomous for cubes function
void redCubeautonomous()
{
	clearencoders();// clears the encoders


	SensorValue[CLAW] = 1;//closes claw on preload

	pidDrivecontrol(-500,-510,-490,1,1,2);//brings the drive back to -500 degrees

	wait1Msec( 100);//waits .1 second before executing the lift function

	pidLiftcontrol(-310,-320,-300,-1,-1,1);//lifts the lift to the appropriate height of the post

	wait1Msec( 200);//waits .2 second before executing the drive forward function

	pidDrivecontrol(165,155,175,1,1,5);//drives slightly forward to align the cube up with the pole

	wait1Msec( 200);//waits .2 second before executing the lift function

	pidLiftcontrol(150,140,160,-1,-1,1);//puts cube on the pole

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;// releases the claw

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-360,-365,-355,1,1,2);//brings the drive back to -360 degrees and this results in a score of the cube

	wait1Msec( 150);//waits .15 second before executing

	pidLiftcontrol(200,190,210,-1,-1,1);//lowers the lift to the appropriate height to grab  a cube to score

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(240,235,245,-1,1,1);//turns right to position itself to grab the cube

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 1;// cloeses the claw on the cube, hopefully

	wait1Msec( 500);//waits .5 second before executing

	pidDrivecontrol(-250,-255,-245,1,1,2); //backs up to allow room to turn

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-300,-305,-295,-1,1,2);//turns left to score the cube in the colored square

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(360,355,365,1,1,2);//drives forward to ensure the cube is in the colored square

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;// drops cube in colored square

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-720,-725,-715,1,1,2);//brings the drive back to -720 degrees to clear itself
}
//red autonomous for cubes function
void blueCubeautonomous()
{
	clearencoders();


	SensorValue[CLAW] = 1;//closes claw on preload

	pidDrivecontrol(-500,-510,-490,1,1,2);//brings the drive back to -500 degrees

	wait1Msec( 100);//waits .1 second before executing the lift function

	pidLiftcontrol(-310,-320,-300,-1,-1,1);//lifts the lift to the appropriate post height

	wait1Msec( 200);//waits .2 second before executing the drive forward function

	pidDrivecontrol(165,155,175,1,1,5);//drives forward to position the cube for scoring

	wait1Msec( 200);//waits .2 second before executing the lift function

	pidLiftcontrol(150,140,160,-1,-1,1);//puts cube on the pole

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;// releases the cube onto the pole

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-360,-365,-355,1,1,2);//brings the drive back to -360 degrees-- results in a score of a cube

	wait1Msec( 150);//waits .15 second before executing

	pidLiftcontrol(200,190,210,-1,-1,1);//lowers the lift to position for the scoring of the second cube

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(300,295,305,-1,1,2);//turns left to move the cube into the blue square

	pidDrivecontrol(165,155,175,1,1,5);//moves the robot forward to grab the cube

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 1;// grabs the cube

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-250,-255,-245,1,1,2); //backs up to get out of the way

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-220,-225,-215,-1,1,2);//turns right to move the ucbe intot he colored square

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(360,355,365,1,1,2);//drives forward to ensure that the cube is scored

	wait1Msec( 150);//waits .15 second before executing

	SensorValue[CLAW] = 0;// drops cube in colored square

	wait1Msec( 150);//waits .15 second before executing

	pidDrivecontrol(-720,-725,-715,1,1,2);//brings the drive back to -720 degrees or moves the robot back two turns

}
//blue autonomous for skyrise function
void blueSkyriseautonomous()
{ //-1458.51243217 degrees will position the robot exactly 1.5 squares -- diagonal-- from the skyrise autoloader
	//the diameter of the wheen is 4pi inches. The squares are apporx 23.41 inches^2 in area.
	clearencoders();

	pidDrivecontrol(-500,-510,-490,1,1,2);//brings the drive back to -500 degrees

	pidLiftcontrol(-185,-195,-175,-1,-1,5);//should lift the lift to the autoloaders height----- must perfect the height value via trial and error calculations

	pidDrivecontrol(350,340,360,1,1,2);//drives forward to  grab the skyrise

	waitInMilliseconds(150);//waits .15 seconds before executing

	SensorValue[CLAW] = 1;//closes claw on skyrise

	pidLiftcontrol(-125,-135,-115,-1,-1,3);//should lift the skyrise out of the autoloader

	waitInMilliseconds(150);//waits .15 seconds before executing

	pidDrivecontrol(-270,-275,-265,1,1,2);//brings the drive back to -270 degrees

	pidDrivecontrol(155,150,160,-1,1,3);//turns right to position the skyrise to be scored

	pidDrivecontrol(70,65,75,1,1,3);// drives slightly forward to align itself with the skyrise

	pidLiftcontrol(180,170,190,-1,-1,4);//lowers lift to score skyrise

	SensorValue[CLAW] = 0;//releases claw

	pidDrivecontrol(-500,-510,-490,1,1,2);//brings the drive back to -500 degrees to get it out of the way

	/***********************************************************************************************************

	Deleted code that scores a second skyrise

	/**********************************************************************************************************

	pidDrivecontrol(-150,-160,-140,1,1,2);//brings the drive back to -720 degrees or moves the robot

	pidLiftcontrol(-60,-70,-50,-1,-1,2);//raises lift

	pidDrivecontrol(-130,-140,120,1,-1,3);//turns left

	pidDrivecontrol(-260,-265,-255,-1,-1,2);//brings the drive back to -360 degrees or moves the robot back one turn

	SensorValue[CLAW] = 1;//releases claw

	pidLiftcontrol(-125,-135,-115,-1,-1,3);//should lift the lift to the autoloaders height

	pidDrivecontrol(155,150,160,-1,1,3);//turns right

	pidDrivecontrol(70,65,75,1,1,3);

	pidLiftcontrol(180,170,190,-1,-1,4);//lowers lift to score skyrise

	SensorValue[CLAW] = 0;//releases claw
	*/
}


//blue autonomous for skyrise function
void redSkyriseautonomous()
{
	//-1458.51243217 degrees will position the robot exactly 1.5 squares -- diagonal-- from the skyrise autoloader
	//the diameter of the wheen is 4pi inches. The squares are apporx 23.41 inches^2 in area.
	clearencoders();

	pidDrivecontrol(-500,-510,-490,1,1,2);//brings the drive back to -500 degrees in order to make room for the lift expansion

	pidLiftcontrol(-185,-195,-175,-1,-1,5);//should lift the lift to the autoloaders height----- must perfect the height value via trial and error calculations

	pidDrivecontrol(350,340,360,1,1,2);//drives forward to grab the skyrise

	SensorValue[CLAW] = 1;//closes claw on skyrise

	pidLiftcontrol(-125,-135,-115,-1,-1,3);//should lift the skyrise out of the autoloader

	waitInMilliseconds(150);//waits .15 seconds before executing

	pidDrivecontrol(-270,-275,-265,1,1,2);//brings the drive back to -270 to allow for positioning over the skyrise dock

	pidDrivecontrol(-275,-285,-265,-1,1,3);//turns left to align itself over the skyrise dock

	pidDrivecontrol(80,75,85,1,1,3);// frives forward to align itself with the skyrise dock

	pidLiftcontrol(180,170,190,-1,-1,4);//lowers lift to score skyrise

	SensorValue[CLAW] = 0;//releases claw

	pidDrivecontrol(-500,-510,-490,1,1,2);//brings the drive back to -720 degrees or moves the robot back two turns
	/***********************************************************************************************************

	Deleted code that scores a second skyrise

	/**********************************************************************************************************


	pidDrivecontrol(-150,-160,-140,1,1,2);//brings the drive back to -720 degrees or moves the robot

	pidLiftcontrol(-60,-70,-50,-1,-1,2);//raises lift

	pidDrivecontrol(-130,-140,120,1,-1,3);//turns left

	pidDrivecontrol(-260,-265,-255,-1,-1,2);//brings the drive back to -360 degrees or moves the robot back one turn

	SensorValue[CLAW] = 1;//releases claw

	pidLiftcontrol(-125,-135,-115,-1,-1,3);//should lift the lift to the autoloaders height

	pidDrivecontrol(155,150,160,-1,1,3);//turns right

	pidDrivecontrol(70,65,75,1,1,3);

	pidLiftcontrol(180,170,190,-1,-1,4);//lowers lift to score skyrise

	SensorValue[CLAW] = 0;//releases claw
	*/
}

task strafeButtoncontrol()
{

	//The following controls the strafe wheel
	if(vexRT[Btn8R] == 1)
	{
		strafe(127);
	}

	else if(vexRT[Btn8L] == 1)//Btn 8l goes left
	{
		strafe(-127);
	}
	else
	{
		strafe(0);
	}
}

task strafeTiltcontrol()						//TILT code
{
	int STRFthreshold=50;				//Threshold value obtained empirically. 36 works best
	while(1==1)
	{

		if((vexRT[AccelX] < (-1 * STRFthreshold))) //controller tilted LEFT beyond threshold (NEGATIVE value)
		{
			strafe(-127);		//LEFT
		}
		else if((vexRT[AccelX] > (STRFthreshold))) //controller tilted RIGHT beyond threshold (POSITIVE value)
		{
			strafe(127);			//RIGHT
		}
		else
		{
			strafe(0);
		}
	}
}
//Strafe toggle---------------------------------------------------------------------------------------
//Control variable "toggle" = true/false- TRUE = tilt; FALSE = button
//																	//Toggle controlled by btn7R

task STRFControl()
{

	//TOGGLE CONTROL STRUCTURE
	while(1==1)
	{
		if(vexRT[btn7R] == 1)
		{
			startTask (strafeTiltcontrol);
			stopTask (strafeButtoncontrol);								//set true
		}
		if(vexRT[Btn7L] == 1)
		{
			startTask (strafeButtoncontrol);
			stopTask (strafeTiltcontrol);								//set  false
		}
	}
}


/*
task STRFCode()
{
while(1==1)
{
if(toggle == true)
{
startTask (strafeTiltcontrol);
stopTask (strafeButtoncontrol);
}
if(toggle == false)
{
startTask (strafeButtoncontrol);
stopTask (strafeTiltcontrol);
}
}
}
*/
task postheights()//ONLY use when the lift is at its floor position.--Grab cube and then press the buttons
{
	while(1==1)
	{
		if( vexRT[Btn7U]==1)//sets the lift to the height of the small pole
		{
			clearencoders();
			pidLiftcontrol(-310,-320,-300,-1,-1,2);//lifts the lift to the appropriate post height
			clearencoders();
		}

		if( vexRT[Btn7D]==1)//sets the lift to the height of the medium pole
		{
			clearencoders();
			pidLiftcontrol(-310,-320,-300,-1,-1,2);//lifts the lift to the appropriate post height
			clearencoders();
		}


		if( vexRT[Btn8U]==1)//sets the lift to the height of the tall pole
		{
			clearencoders();
			pidLiftcontrol(-310,-320,-300,-1,-1,2);//lifts the lift to the appropriate post height
			clearencoders();
		}

	}

}


task tiltDrive()
{
	int driveThreshold=36;				//Threshold value obtained empirically. 36 works best
	while(vexRT[Btn8D]==1)
	{
		if((abs(vexRT[AccelY]) > ( driveThreshold))) //controller tilted forward beyond threshold (positive value)
		{
			driveSpeedleft(vexRT[AccelY]);
			driveSpeedright(vexRT[AccelY]);

		}
		if((vexRT[AccelX] > ( driveThreshold))) //controller tilted right beyond threshold (positive value)
		{
			driveSpeedleft(vexRT[AccelX]);
			driveSpeedright(-1*vexRT[AccelX]);

		}
		if((vexRT[AccelX] < ( -1*driveThreshold))) //controller tilted left beyond threshold (negative value)
		{
			driveSpeedleft(vexRT[AccelX]);
			driveSpeedright(-1*vexRT[AccelX]);

		}

	}
}

/*the following is a backup autonomous

/*task autonomous()
{
if (SensorValue[AUTOCHANGE]==1)//changes autonomous to blue
{	//Clear Encoders
SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

waitInMilliseconds(500);

//closes claw
SensorValue[CLAW] = 1;



//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127)  ;

//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127) ;
startMotor(LeftRear,-127) ;

untilEncoderCounts(720, dgtl6);//backwards for 2 turns

stopMotor(RightFront);//kills drive motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);




//autonomous lift


startMotor(LeftBottom,127) ;//Lift goes up
startMotor(RightBottom,127);
startMotor(LeftTop,127) ;
startMotor(RightTop,127) ;

untilEncoderCounts(450, dgtl2);//goes up until encoder reaches 450 degrees

stopMotor(LeftBottom);//stops lift
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//--------------------------------------------------



//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;

//Left side of the robot is foward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(400, dgtl6);// forward


stopMotor(RightFront);//this stops all the motors from moving
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(200, dgtl2);//contines to go down until the encoder reads 200 degrees.


stopMotor(LeftBottom);//Then the lift motors will turn off
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);


waitInMilliseconds(250);//To ensure stability a wait time has been placed

SensorValue[CLAW] = 0;//The claw releases

waitInMilliseconds(250);

//Right side of the robot is backward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(-360, dgtl6);//The robot should reverse 360 degrees



stopMotor(RightFront);//stops all motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(100);
//------------------------------------------------------------------------------

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(-250, dgtl2);// goes back

stopMotor(LeftBottom);//stops the lift motors
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);


//clears the sensor values to make programming easier

SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

//Right side of the robot is forward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-180,dgtl6);//turns left about 50 degrees--- was positive

stopMotor(RightFront); //kills the turn
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);


//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-160, dgtl6);//robot moves forward


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);

SensorValue[CLAW] = 1;//closes claw around the cube on the left

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is Backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(120, dgtl6);//robot moves backwards


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);

//Right side of the robot is backward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is foward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(220, dgtl6);//turns right to swing the cube

stopMotor(RightFront); //kills the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);
waitInMilliseconds(250);
//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-120, dgtl6);//robot moves forward until the wheels go approximately 1/3 turn--- was negative


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);




waitInMilliseconds(250);

SensorValue[CLAW] = 0;//Releases claw

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(540, dgtl6);//backwards for a few turns
stopMotor(RightFront);//kills motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

}



//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
//This is for red side

if (SensorValue[AUTOCHANGE]==0)//changes autonomous to red
{
//clears encoders
SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

waitInMilliseconds(500);

//closes claw
SensorValue[CLAW] = 1;



//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127)  ;

//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127) ;
startMotor(LeftRear,-127) ;

untilEncoderCounts(720, dgtl6);//backwards for 2 turns

stopMotor(RightFront);//kills drive motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);




//autonomous lift


startMotor(LeftBottom,127) ;//Lift goes up
startMotor(RightBottom,127);
startMotor(LeftTop,127) ;
startMotor(RightTop,127) ;

untilEncoderCounts(450, dgtl2);//goes up until encoder reaches 450 degrees

stopMotor(LeftBottom);//stops lift
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//--------------------------------------------------



//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;

//Left side of the robot is foward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(360, dgtl6);// 1 full rotation


stopMotor(RightFront);//this stops all the motors from moving
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(500);

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(200, dgtl2);//contines to go down until the encoder reads 200 degrees.


stopMotor(LeftBottom);//Then the lift motors will turn off
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);


waitInMilliseconds(250);//To ensure stability a wait time has been placed

SensorValue[CLAW] = 0;//The claw releases

waitInMilliseconds(250);

//Right side of the robot is backward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(-360, dgtl6);//The robot should reverse 360 degrees-----



stopMotor(RightFront);//stops all motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(100);
//------------------------------------------------------------------------------

startMotor(LeftBottom,-127) ;//Lift goes down
startMotor(RightBottom,-127);
startMotor(LeftTop,-127) ;
startMotor(RightTop,-127) ;


untilEncoderCounts(-250, dgtl2);//moves backward for -250 degrees

stopMotor(LeftBottom);//stops the lift motors
stopMotor(RightBottom);
stopMotor(LeftTop);
stopMotor(RightTop);

waitInMilliseconds(500);
//------------------------------------------------------------------------


//clears the sensor values to make programming easier

SensorValue[DriveLeft] = 0;
SensorValue[DriveRight] = 0;
SensorValue[LiftLeft] = 0;
SensorValue[LiftRight] = 0;

//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is backward at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(180,dgtl6);//turns left about 50 degrees--- was positive

stopMotor(RightFront); //kills the turn
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);


//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(160, dgtl6);//robot moves forward


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);

SensorValue[CLAW] = 1;//closes claw around the cube on the left

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is Backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(120, dgtl6);//robot moves backwards


stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);
//Right side of the robot is backward at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is foward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(220, dgtl6);//turns right to swing the cube into the floor goals

stopMotor(RightFront); //kills the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);

waitInMilliseconds(250);
//Right side of the robot is forward at full speed
startMotor(RightFront,127) ;
startMotor(RightRear,127) ;
//Left side of the robot is forward at full speed
startMotor(LeftFront,127);
startMotor(LeftRear,127)  ;

untilEncoderCounts(-120, dgtl6);//robot moves forward

stopMotor(RightFront);//stops the motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);
waitInMilliseconds(250);

SensorValue[CLAW] = 0;//Releases claw

waitInMilliseconds(250);

//Right side of the robot is backwards at full speed
startMotor(RightFront,-127) ;
startMotor(RightRear,-127) ;
//Left side of the robot is backwards at full speed
startMotor(LeftFront,-127);
startMotor(LeftRear,-127)  ;

untilEncoderCounts(540, dgtl6);//backwards for a few turns

stopMotor(RightFront);//kills motors
stopMotor(RightRear);
stopMotor(LeftFront);
stopMotor(LeftRear);
}

}
*/
