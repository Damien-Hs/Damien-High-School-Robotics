#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Motor,  port4,           LL1,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           LL2,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           LR1,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           LR2,           tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



//***************************************************************************************
//														Damien Robotics Academy
//																Code Template
//***************************************************************************************



/*
Team:							6526D
Robot:						N/A
Code:							Lift DUAL PID Control Template

Conception Date: 	4/12/2015
Purpose:					Template for manual and autonomic PID control of a lift mechanism

Code Version:			v.1.0
Status:						Applicable
Date:							4/13/2015

NOTES:

This code was designed for use with a potentiometer. Computations of the target values
reflect such an approach; in order to utilize an encoder, additional computations and
clearing may be necessary.

Motor and sensor names must be changed to match those of main code.

This is NOT a stand-alone robot code; it must be paired with other autonomous / driver
control code.

The default variables are suitable for 6526D5603E.

*/



/////////////////////////////////////////////////////////////////////////////////////////
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
/////////////////////////////////////////////////////////////////////////////////////////



//*****DEFINITIONS******

#define LPID_SENSOR_INDEX			liftPot					// Specify the lift sensor
#define LPID_SENSOR_SCALE			(1)							// Scale the sensor value if necessary by multiplying by a constant
#define LPID_SENSOR_DISP			(-1760)					// Shift the sensor values (if using a potentiometer) so that "zero" is another value



#define LIFT_UP_BUTTON			btn6U							// BUTTON CONTROL- Specify which buttons are used to raise and lower lift
#define LIFT_DOWN_BUTTON		btn6D
//OR
#define JOY_L								Ch2								// JOYSTICK CONTROL- Specify the control joystick axis



#define LIFT_POS1_BTN				btn7U							// Specify the buttons to trigger autonomic PID for each different position
#define LIFT_POS2_BTN				btn7R
#define LIFT_POS3_BTN				btn7D

const int POS1 = 3710;												// Specify position values for autonomic PID. These values are unscaled
const int POS2 = 3000;
const int POS3 = 2500;

const int Lift_Pos_Max = 3660;								// Define maximum and minimum position values
const int Lift_Pos_Min = 1760;								// These values are not scaled or displaced- simply read them from the debugger
//																						// when the arm is raised to max and lowered to min
int LPOS_Max_Scaled;													// Variables to store scaled limits
int LPOS_Min_Scaled;


#define LPID_MOTOR_SCALE     (-1)							// Modify to scale the motor speed. MUST BE NEGATIVE



#define LPID_SPEED_MAX       127							// Define maximum and minimum motor speeds
#define LPID_SPEED_MIN     (-127)



#define LPID_INTEGRAL_LIMIT  (50)							// Define a limit that error values less than or equal to it will be integrated.



#define LSpeed_Refresh_Time	(5)								// Define the rate at which the speed calculation repeats (period), in ms



const int deltaTargetL = 12;									// Define how much the target value changes per cycle of the control task (BUTTON CONTROL)
const int LControl_Scale = (1/127);						// Define the proportionality constant multiplied by the joystick value and delta target
//																						// to give motor speed. Normally (1/127)

#define TargetL_Refresh_Time	(10)						// Define the rate at which the target value calculation repeats (period), in ms


// Define constants
float  pidL_Kp = 0.3;
float  pidL_Ki = 0.0;
float  pidL_Kd = 0.3;

static int   pidRunning = 1;									// Variable to indicate whether PUD os activated or not. Allows PID to be turned off
static float pidTargetL;											// Target value



//***** FUNCTIONS *****



void LPID (float LPIDSpeed)										// Function to assign a speed "LPIDSpeed" to lift motors
{																							// This will be used to set all lift motors' speed equal to the calculated PID speed
	motor[LL1] = LPIDSpeed;											// Add, remove, or rename lift motors as necessary
	motor[LL2] = LPIDSpeed;
	motor[LR1] = LPIDSpeed;
	motor[LR2] = LPIDSpeed;
}



//***** SPEED CALCULATION *****

//Insert this task near the driver control code. It will be called  by the target calculation task.
task LiftPID()
{
	float  pidLSensorCurrentValue;

	float  pidLError;
	float  pidLLastError;
	float  pidLIntegral;
	float  pidLDerivative;
	float  pidLSpeed;

	// Initialize the variables at 0
	pidLLastError  = 0;
	pidLIntegral   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidLSensorCurrentValue = ((SensorValue[ LPID_SENSOR_INDEX ] + (LPID_SENSOR_DISP)) * (LPID_SENSOR_SCALE));

			// calculate error
			pidLError = pidLSensorCurrentValue - pidTargetL;

			// integral - if Ki is not 0
			if( pidL_Ki != 0 )
			{
				// If the error is less than the integral limit, then integrate the error
				if( abs(pidLError) < LPID_INTEGRAL_LIMIT )
					pidLIntegral = pidLIntegral + pidLError;
				else
					pidLIntegral = 0;
			}
			else
				pidLIntegral = 0;

			// calculate the derivative (difference)
			pidLDerivative = pidLError - pidLLastError;
			pidLLastError  = pidLError;

			// calculate lift motor velocity
			pidLSpeed = (pidL_Kp * pidLError) + (pidL_Ki * pidLIntegral) + (pidL_Kd * pidLDerivative);

			// limit velocity
			if( pidLSpeed > LPID_SPEED_MAX )
			{
				pidLSpeed = LPID_SPEED_MAX;
			}
			if( pidLSpeed < LPID_SPEED_MIN )
			{
				pidLSpeed = LPID_SPEED_MIN;
			}

			// send to motor
			LPID((pidLSpeed * LPID_MOTOR_SCALE));
		}
		else
		{
			// clear all
			pidLError      = 0;
			pidLLastError  = 0;
			pidLIntegral   = 0;
			pidLDerivative = 0;
			LPID(0);
		}

		wait1Msec( LSpeed_Refresh_Time );					//Wait to refresh calculation
	}
}



//***** TARGET CALCULATION *****

// Insert this function near the driver control code. It will be called  by the main usercontrol task
task LPIDControl()
{
	// initialize target at the current senor value when robot is turned on, accounting for displacement and scale
	pidTargetL = ((SensorValue[ LPID_SENSOR_INDEX ] + ( LPID_SENSOR_DISP )) * (LPID_SENSOR_SCALE));

	// initialize scaled versions of position limits
	LPOS_Max_Scaled = ( (Lift_Pos_Max + LPID_SENSOR_DISP) * (LPID_SENSOR_SCALE) );
	LPOS_Min_Scaled = ( (Lift_Pos_Min + LPID_SENSOR_DISP) * (LPID_SENSOR_SCALE) );

	// start the PID speed calculation task
	startTask( LiftPID );

	while( true )
	{


// <><><> MANUAL CONTROL <><><>

//For a BUTTON-controlled PID, leave this section uncommented
//For a JOYSTICK-controlled PID, comment this section

		if((vexRT[ LIFT_UP_BUTTON ] == 1))
		{
			pidTargetL = pidTargetL + (deltaTargetL);
		}
		if((vexRT[ LIFT_DOWN_BUTTON ] == 1))
		{
			pidTargetL = pidTargetL - (deltaTargetL);
		}

//For a JOYSTICK-controlled PID, uncomment this section
//For a BUTTON-controlled PID, comment this section
		/*
		pidTargetL = pidTargetL + ((LControl_Scale) * (deltaTargetL) * (vexRT[ JOY_L ]))
		*/



// <><><> Autonomic control <><><>

		while((vexRT[LIFT_UP_BUTTON] == 0) && (vexRT[LIFT_DOWN_BUTTON] == 0))
		//While no lift input is provided
		{
			// If one of the autonomic PID control buttons is pressed, set the target equal to the corresponding scaled position
			if(vexRT[LIFT_POS1_BTN] == 1)
			{
				pidTargetL = ( (POS1 + LPID_SENSOR_DISP) * (LPID_SENSOR_SCALE) );
			}
			if(vexRT[LIFT_POS2_BTN] == 1)
			{
				pidTargetL = ( (POS2 + LPID_SENSOR_DISP) * (LPID_SENSOR_SCALE) );
			}
			if(vexRT[LIFT_POS3_BTN] == 1)
			{
				pidTargetL = ( (POS3 + LPID_SENSOR_DISP) * (LPID_SENSOR_SCALE) );
			}
		}

		//Target limit to ensure that motor is not opposing a mechanical stop
		if( (pidTargetL) > (LPOS_Max_Scaled) )
		{
			pidTargetL = LPOS_Max_Scaled;
		}
		if( (pidTargetL) < (LPOS_Min_Scaled) )
		{
			pidTargetL = (LPOS_Min_Scaled);
		}

		wait1Msec( TargetL_Refresh_Time );					//Wait to refresh calculation
	}
}



//***** MAIN CODE *****



void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{}

task usercontrol()
{
	// Insert other driver control code here

	startTask(LPIDControl);			// Start the PID tasks
}
