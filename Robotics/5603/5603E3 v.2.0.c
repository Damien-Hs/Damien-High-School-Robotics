#pragma config(Sensor, in1,    autoPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LENC,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RENC,           sensorQuadEncoder)
#pragma config(Sensor, dgtl12, LED,            sensorLEDtoVCC)
#pragma config(Motor,  port1,           dLR,           tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port2,           dLF,           tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           dRF,           tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port4,           LL1,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           LL2,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           LR1,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           LR2,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           CB,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           STRF,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          dRR,           tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



/*************************************************************************************************************************************************
PINOUT
**************************************************************************************************************************************************/
/*

Analog
autoPot				autonomous selector potentiometer
liftPot				lift potentiometer
clawPot				claw potentiometer

Digital
LENC					lef encoder, rear wheel
RENC					right encoder, rear wheel

Motors
dLR						drive, left rear motor			3:2			100 rpm
dLF						drive, left front motor			3:2			100 rpm
dRF						drive, right front motor		3:2			100 rpm
LL1						lift, one left motor				5:1			100 rpm								As the lift is synchronized, which lift motor is 1 or 2 does not matter
LL2						lift, one left motor				5:1			100 rpm
LR1						lift, one right motor				5:1			100 rpm
LR2						lift, one right motor				5:1			100 rpm
CB						claw motor									3:1			100 rpm
STRF					strafe wheel motor					1:1			100 rpm
dRR						drive, right rear motor			3:2			100 rpm

*/




/*************************************************************************************************************************************************
CHANGELOG
**************************************************************************************************************************************************/
/*

5603B FINAL		Final 6526D 2014-2015 regular season competition code (24.1.2015, Hesperia, CA)


5603E1 v.1.0	Strafe wheel controls changed from buttons 8L, 8R to remote tilt
5603E1 v.1.1	Organized autonomous code by using functions, deleted bilingual comments, added variable repository, reduced code length
5603E1 v.1.2	Added pinout information. Removed unnecessary autoTester potentiometer


5603E2 v.0.1	Added ezperimental P loop to lift. Claw will now have continuous low power applied when grabbing an object. A second P loop
added to claw, to hold the claw open when desired. Values and constants stored in repository. Lift down speed changed to
-70 msu. Backups of manual (non-P) controls added, in comment form.
5603E2 v.0.3	Organized usercontrol code by functions. Replaced while 1==1 in P loop with do-while(control == 0) It works, but kPs need tuning
5603E2 v.0.4	Added a toggle button(7R) for switching between tilt and button strafe. Does not work
5603E2 v.0.5 	New PID experiment. Reorganized functions.

5603E2 v.1.0	Added first working lift PID, from experimental code. Updated variable repository

5603E2 v.2.0	New compilation of code to avoid Mechanical Chicken Effect

5603E3 v.1.0	Adapted 5603E2 to complete tilt control.
5603E3 v.2.0	Codified tilt control function and improved scaling constants

*/



/*************************************************************************************************************************************************
VARIABLE REPOSITORY
**************************************************************************************************************************************************/
/*

a( PMA + CB )		autonomous with cube dump procedure (PMA) and cube grab procedure (CB)

<PMA>
forward									45 degE						degrees/encoder
liftup									2180 countP				counts of potentiometer
liftdown								1760 countP
back										-38 degE
turn										200 degE


<CB>
forward									270 degE
turn180									580 degE
forward									90 degE
back										2000 ms


Autonomous selector: located at 0, -90, and -180 deg about potentiometer
500		countP
1900	countP
3500	countP


Normal lift code speeds
up											70 msu							--The msu is a unit representing programmed motor speed
down										-70 msu							Conversion: (motor RPM rating- 100, 160, or 240) x (programmed msu / 127 msu) = (actual motor RPM)
(RPM) x ((2pi rad)/(60 s)) = motor speed (rad/s)


Lift
kP											0.3
kI											0
kD 											0.3
Lift_Pos_Min						1760 countP
Lift_Pos_Max						3660 countP
PID_INTEGRAL_LIMIT 			50
PID_MOTOR_SCALE					-1
PID_SENSOR_SCALE				1
speed refresh						5 ms								Interval (period)  between each calculation of speed
-												200 Hz
target refresh					10 ms								Interval (period)  between each calculation of target value
-												100 Hz
deltaTarget							15 countP 					(per (target refresh))
dT/dt										1500 countP/s				Rate of change of deltaTarget


Tilt Strafe
threshold								36
speed										127 msu


Claw
maximum open						1440 countP 					(range is > 1440)
autoclamp threshold			>= 2200	countP
autoclamp speed					10 msu
autoopen threshold			<= 1800 countP
autoopen speed					10 msu


Lift Data (collected by empirical methods and Sun's Lift Formulas)
ideal height						53.7 in													determined by the Bar Height Formula
actual height						49.5 in													empirically measured
height efficiency				0.93														ratio of actual height to ideal height
--How efficient is the lift in terms of height? (Will never > 1)
ideal speed							36.5 in/s												determined by differential calculus applied to ideal height and angular speed of motor
--What is the ideal vertical speed of the claw, not considering friction and weight?
actual speed (up)				24.75 in/s											actual height divided by time
actual speed(down)			20 in/s (estimated)							actual height divided by time
speed efficiency				0.68														ratio of actual up speed to ideal up speed
--How efficient is the lift in terms of time to rise up?
**This (< 1) means that the lift is not as fast as it can be. Motor speed dows not matter.
G coefficient						1.24 														ratio of actual up speed to actual down speed
--Are rubber bands helping the lift to go up faster than going down?
**This (> 1) means that the lift is going up faster than it is going down.

*/



/*************************************************************************************************************************************************
AUTONOMOUS - DEFINITIONS
**************************************************************************************************************************************************/



/*
8 Autonomi. L for left, R for right.

autoPot LEFT UP					PMA (cube dump and grabbing cube out of square) for BLUE
autoPot LEFT DOWN				cube grab out of square (general, 180 deg turn LEFT)
autoPot RIGHT DOWN			cube grab out of square (general, 180 deg turn RIGHT)
autoPot RIGHT UP. 			PMA for RED = RIGHT)
*/



//*****SIMPLE BEHAVIORS*****

void clear();					//Clear all encoders and sensors

void closeClaw();			//claw close function
void closeClaw1();		//claw close function- longer motor run time
void openClaw();			//claw open function

//*****ROUTINE COMPONENTS*****

void CBLeft();				//Cube grab run (left turn)
void CBRight();				//Cube grab run (right turn)

void PMA();						//Cube dump run

//*****TRANSITIONS*****

void alignLeft();			//for the BLUE <PMA + CB>- Align the robot so that the field perimeter is to its left
void alignRight();		//for the RED <PMA + CB>- Align the robot so that the field perimeter is to its right



/*************************************************************************************************************************************************
PRIMARY AUTONOMOUS FUNCTION
**************************************************************************************************************************************************/



void autoTest()
//This is the autonomous code, used in task autonomous and usercontrol tester for ease of modification
//All previous functions are used in this function
{
	clear();					//Clear encs and timers

	//*****PMA, RED SIDE*****

	if((SensorValue[autoPot] <= 500) && (SensorValue[autoPot] >= 0))
	{
		PMA();					//Run the cube dump function. The following commands transition the robot to proper position for CB.

		alignRight();		//transition to CB position

		CBLeft();				//Run the cube grab function with a left 180deg turn.
	}

	//*****CUBE GRAB, LEFT TURN*****

	if((SensorValue[autoPot] <= 3500) && (SensorValue[autoPot] > 1900))
	{
		CBLeft();				//Run the cube grab function with a left 180deg turn.
	}

	//*****CUBE GRAB, RIGHT TURN*****

	if((SensorValue[autoPot] <= 1900) && (SensorValue[autoPot] > 500))
	{
		CBRight();			//Run the cube grab function with a right 180deg turn.
	}

	//*****PMA, BLUE SIDE*****

	if((SensorValue[autoPot] <= 4095) && (SensorValue[autoPot] > 3500))
	{
		PMA();					//Run the cube dump function. The following commands transition the robot to proper position for CB.

		alignLeft();		//transition to CB position

		CBRight();			//Run the cube grab function with a right 180deg turn.
	}
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////



void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
	clear();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	autoTest();

	//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}



/*************************************************************************************************************************************************
AUTONOMOUS FUNCTIONS- SIMPLE BEHAVIORS
**************************************************************************************************************************************************/



void setDriveSpeed (int dSpeed)
//drive code block
{
	motor[dLF] = dSpeed;
	motor[dLR] = dSpeed;
	motor[dRF] = dSpeed;
	motor[dRR] = dSpeed;
}



void clear()
//Clear encs and timers
{
	SensorValue[dgtl1] = 0;
	SensorValue[dgtl3] = 0;
	clearTimer(T1);
	clearTimer(T2);
	clearTimer(T3);
	clearTimer(T4);
}



void closeClaw()
//close claw function for autonomous
{
	motor[CB] = 60;
	waitInMilliseconds(650);
	motor[CB] = 0;
}



void closeClaw1()
//special closeClaw function, extra long
{
	motor[CB] = 60;
	waitInMilliseconds(850);
	motor[CB] = 0;
}



void openClaw()
//open claw function for autonomous
{
	motor[CB] = -60;
	waitInMilliseconds(900);
	motor[CB] = 0;
}



/*************************************************************************************************************************************************
AUTONOMOUS- ROUTINE COMPONENTS
**************************************************************************************************************************************************/



void CBLeft()
//This is the cube grab run common to both kinds of autonomous. The 180 deg turn is made LEFT
{
	//Robot moves forward for about 13 inches to first cube outside of start square
	setDriveSpeed(127);

	untilEncoderCounts(270, dgtl1);

	setDriveSpeed(0);

	//Release the claw motor (that was held open by the previous PMA function if cube was dumped, or simply does nothing if cube dump was not used)
	motor[CB] = 0;

	//Close claw on cube
	closeClaw();

	//Keep motor running to ensure grip
	motor[CB] = 20;

	//Robot makes 180 deg point turn LEFT using the right enc to navigate
	SensorValue[dgtl3] = 0;

	motor[dLF] = -127;
	motor[dLR] = -127;
	motor[dRF] = 127;
	motor[dRR] = 127;

	untilEncoderCounts(580, dgtl3);

	//Robot returns to starting square
	SensorValue[dgtl1] = 0;
	SensorValue[dgtl3] = 0;

	setDriveSpeed(127);

	untilEncoderCounts(90, dgtl1);

	setDriveSpeed(0);

	//Releases claw motor to prepare for opening claw
	motor[CB] = 0;

	//Open claw to release cube
	openClaw();

	//Back away for 2 s
	setDriveSpeed(-127);

	waitInMilliseconds(2000);

	setDriveSpeed(0);

	//END- clear encs
	clear();
}



void CBRight()
//This is the cube grab run common to both kinds of autonomous. The 180 deg turn is made RIGHT
{
	//Robot moves forward for about 13 inches to first cube outside of start square
	setDriveSpeed(127);

	untilEncoderCounts(270, dgtl1);

	setDriveSpeed(0);

	//Release the claw motor (that was held open by the previous PMA function if cube was dumped, or simply does nothing if cube dump was not used)
	motor[CB] = 0;

	//Close claw on cube
	closeClaw1();

	//Keep motor running to ensure grip
	motor[CB] = 20;

	//Robot makes 180 deg point turn RIGHT using the left enc to navigate
	SensorValue[dgtl1] = 0;

	motor[dLF] = 127;
	motor[dLR] = 127;
	motor[dRF] = -127;
	motor[dRR] = -127;

	untilEncoderCounts(580, dgtl1);

	//Robot returns to starting square
	SensorValue[dgtl1] = 0;
	SensorValue[dgtl3] = 0;

	setDriveSpeed(127);

	untilEncoderCounts(90, dgtl1);

	setDriveSpeed(0);

	//Releases claw motor to prepare for opening claw
	motor[CB] = 0;

	//Open claw to release cube
	openClaw();

	//Back away for 2 s
	setDriveSpeed(-127);

	waitInMilliseconds(2000);

	setDriveSpeed(0);

	//END, clear ENCs
	clear();
}



void PMA()
//This is the cube dump function that is used to score one cube on the low post at the corner of the non-skyrise start square
//Robot must be set up with the cube on the dump rack, 45 degrees to the arena wall, with rear as close to the corner of
//the start square as possible

//This autonomous behavior is identical for both RED and BLUE
{
	int PMAWaitTime;		//This is currently useless; is not read by the code for unknown reasons.
	//It was intended to keep the lift at the dump position for 200 ms
	PMAWaitTime = 200;

	//Close claw so lift can rise
	closeClaw1();

	//move forward to proper dump position
	setDriveSpeed(127);

	untilEncoderCounts(45,dgtl1);

	setDriveSpeed(0);

	waitInMilliseconds(200);

	//raise lift
	motor[LL1] = 127;
	motor[LL2] = 127;
	motor[LR1] = 127;
	motor[LR2] = 127;

	//stop at this angular position (approx -20 degrees when origin when lift segments are parallel to each other)
	untilPotentiometerGreaterThan(2180, in2);

	motor[LL1] = 0;
	motor[LL2] = 0;
	motor[LR1] = 0;
	motor[LR2] = 0;

	waitInMilliseconds(PMAWaitTime);

	//drop lift
	motor[LL1] = -127;
	motor[LL2] = -127;
	motor[LR1] = -127;
	motor[LR2] = -127;

	untilPotentiometerLessThan(1760, in2);

	//force lift down for an extra 500 ms to ensure that the rubber bands will not force lift to jump up slightly
	waitInMilliseconds(500);

	motor[LL1] = 0;
	motor[LL2] = 0;
	motor[LR1] = 0;
	motor[LR2] = 0;

	//Robot returns to origin
	setDriveSpeed(-127);

	SensorValue(dgtl1)= 0;
	untilEncoderCounts(-38, dgtl1);
	SensorValue(dgtl1)= 0;

	setDriveSpeed(0);

	//open and keep claw open to ensure that the claw is open for grabbing
	openClaw();

	motor[CB] = -15;
}



/*************************************************************************************************************************************************
AUTONOMOUS - ROUTINE TRANSITIONS
**************************************************************************************************************************************************/



void alignLeft()
//The transition from PMA to CBRight of the BLUE side <PMA + CB>
{
	//TURN LEFT 45 deg so robot is parallel to adjacent field perimeter to prepare for cube grab
	SensorValue[dgtl3] = 0;

	motor[dRF] = 127;
	motor[dRR] = 127;

	untilEncoderCounts(200, dgtl3);
	SensorValue[dgtl3] = 0;

	//The perimeter is now at the LEFT of the bot
}



void alignRight()
//The transition from PMA to CBLeft of the RED side <PMA + CB>
{
	//TURN RIGHT 45 deg so robot is parallel to adjacent field perimeter to prepare for cube grab
	SensorValue[dgtl1] = 0;

	motor[dLF] = 127;
	motor[dLR] = 127;

	untilEncoderCounts(200, dgtl1);

	SensorValue[dgtl1] = 0;

	//The perimeter is now at the RIGHT of the bot
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////



/*************************************************************************************************************************************************
DRIVER CONTROL - DEFIITIONS
**************************************************************************************************************************************************/



void autoTester();								//Autonomous tester code call function

task driveControl();							//Primary drive code control structure
task driveController();
task driveJoy();
task driveTilt();
task driveTiltSTRF();

void STRFCode();									//Strafe code controlled by right joystick

task liftPID();										//Lift manual PID control			modifies motor speed
//task LPIDControl();								//Joystick control						modifies target value

task autoPIDControl();						//Autonomic lift positioning control
task autoPIDHigh();								//Set lift to high position
task autoPIDLow();								//Set lift to low position
void aPID(int apidTargetL);				//parametric function
void noAuto();										//Function to disable all autonomic PID

void clawCode();									//claw code



bool driveMode = false;



#define JOY_LEFT						Ch3						// Define drive joysticks
#define JOY_RIGHT						Ch2

#define STRF_LEFT						btn8L					// Define strafe buttons
#define STRF_RIGHT					btn8R

#define LIFT_UP							btn6U					// Define lift buttons- NOT USED
#define LIFT_DOWN						btn6D

#define CLAW_OPEN						btn5D					// Define claw buttons- NOT USED
#define CLAW_CLOSE					btn5U

#define AUTO_TESTER					btn7U					// Define the autonomous tester switch



/*************************************************************************************************************************************************
DRIVER CONTROL AUTOMATIC LIFT CONTROL (ALC) DEFINITIONS
**************************************************************************************************************************************************/


/*
task ACL();							//Primary ACL control structure
task lowPOS();					//Automatic raise to low post position
task maxPOS();					//Automatic raise to maximum position
void autoLift();				//Allows a parametic function setup

int Low_Pos = 2500;			//target values (potentiometer values) for low and medium posts
int High_Pos = 3650;
*/



/*************************************************************************************************************************************************
DRIVER CONTROL PRIMARY TASK
**************************************************************************************************************************************************/



task usercontrol()
{
	clear();																			//clear encs and timers

	//startTask (LPIDControl);											//Start the main PID control task, which will start the PID speed calculation task
	startTask (driveControl);											//Start drive code
	startTask(autoPIDControl);										//Start autonomic PID control structure

	while (1==1)
	{
		autoTester();																//Start normal driving functions
		STRFCode();
		clawCode();
	}
	//UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
}



/*************************************************************************************************************************************************
LIFT PID- MANUAL- DEFINITIONS
**************************************************************************************************************************************************/



#define PID_SENSOR_INDEX    liftPot				//Lift potentiometer
#define PID_SENSOR_SCALE    (1)

void LPID (float LSpeed)								//Function to assign the lift motor speed
{
	motor[LL1] = LSpeed;
	motor[LL2] = LSpeed;
	motor[LR1] = LSpeed;
	motor[LR2] = LSpeed;
}

#define Lift_Pos_Max				(1950)				// = 3660 reading
#define Lift_Pos_Min				(-50)					// = 1760 reading (thereabouts)

#define PID_MOTOR_SCALE     (-1)					// -1 necessary to ensure exponential decay and not growth


#define PID_SPEED_MAX       127						//Minimum and maximum motor speeds
#define PID_SPEED_MIN     (-127)

#define PID_INTEGRAL_LIMIT  50

// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float  pid_Kp = 0.3;
float  pid_Ki = 0.0;
float  pid_Kd = 0.3;

static int   pidRunning = 1;
const float pidTargetL=0;		//Target value



/***************************************************************************************************************************************************
LIFT MANUAL PID
****************************************************************************************************************************************************/



//*****PID TASK*****
//This will be called out by the control task
task liftPID()
{
	float  pidSensorCurrentValue;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidSpeed;

	// Init the variables - thanks Glenn :)
	pidLastError  = 0;
	pidIntegral   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = (SensorValue[ PID_SENSOR_INDEX ] - 1760) * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - pidTargetL;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidSpeed = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidSpeed > PID_SPEED_MAX )
			{
				pidSpeed = PID_SPEED_MAX;
			}
			if( pidSpeed < PID_SPEED_MIN )
			{
				pidSpeed = PID_SPEED_MIN;
			}

			// send to motor
			LPID((pidSpeed * PID_MOTOR_SCALE));
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			LPID(0);
		}

		wait1Msec( 5 );					//Wait 5 ms to refresh this calculation = 200 Hz
	}
}



/***************************************************************************************************************************************************
LIFT AUTOMATIC PID
****************************************************************************************************************************************************/



//*****CONTROL STRUCTURE*****

task autoPIDControl()
{
	while(1==1)
	{
		while((vexRT[btn5U == 0]) && (vexRT[btn5D] == 0))		//While no lift input is provided
		{
			if(vexRT[btn8U] == 1)															//8U- set lift to maximum position
			{
				startTask(autoPIDHigh);
				stopTask(autoPIDLow);
			}
			if(vexRT[btn8D] == 1)															//8D- set lift to low position
			{
				startTask(autoPIDLow);
				stopTask(autoPIDHigh);
			}
		}
		noAuto();
	}
}



task autoPIDLow()
{
	aPID(2500);
}

task autoPIDHigh()
{
	aPID(3710);
}

void aPID (int apidTargetL)
{
	float  pidASensorCurrentValue;
	float  pidAError;
	float  pidALastError;
	float  pidAIntegral;
	float  pidADerivative;
	float  pidASpeed;

	// Init the variables - thanks Glenn :)
	pidALastError  = 0;
	pidAIntegral   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidASensorCurrentValue = (SensorValue[ PID_SENSOR_INDEX ] - 1760) * PID_SENSOR_SCALE;

			// calculate error
			pidAError = pidASensorCurrentValue - apidTargetL;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidAError) < PID_INTEGRAL_LIMIT )
					pidAIntegral = pidAIntegral + pidAError;
				else
					pidAIntegral = 0;
			}
			else
				pidAIntegral = 0;

			// calculate the derivative
			pidADerivative = pidAError - pidALastError;
			pidALastError  = pidAError;

			// calculate drive
			pidASpeed = (pid_Kp * pidAError) + (pid_Ki * pidAIntegral) + (pid_Kd * pidADerivative);

			// limit drive
			if( pidASpeed > PID_SPEED_MAX )
			{
				pidASpeed = PID_SPEED_MAX;
			}
			if( pidASpeed < PID_SPEED_MIN )
			{
				pidASpeed = PID_SPEED_MIN;
			}

			// send to motor
			LPID((pidASpeed * PID_MOTOR_SCALE));
		}
		else
		{
			// clear all
			pidAError      = 0;
			pidALastError  = 0;
			pidAIntegral   = 0;
			pidADerivative = 0;
			LPID(0);
		}

		wait1Msec( 5 );					//Wait 5 ms to refresh this calculation = 200 Hz
	}
}

void noAuto()		//Stop all autonomic positioning tasks
{
	stopTask(autoPIDHigh);
	stopTask(autoPIDLow);
}



/*************************************************************************************************************************************************
DRIVER CONTROL FUNCTIONS
**************************************************************************************************************************************************/



//*****AUTONOMOUS TESTER IN DRIVER CONTROL*****
void autoTester()
{
	//Autonomous Code Tester activated by btn7L
	//COMMENT OUT BEFORE MATCH

	/**/
	if(vexRT[AUTO_TESTER] == 1)
	{
		autoTest();
	}
	/**/
}



//*****CHASSIS CONTROL*****

task driveControl()
{
	while(1==1)
	{
		if(vexRT[btn7D] == 1)
		{
			startTask(driveJoy);
			stopTask(driveTilt);
			stopTask(driveTiltSTRF);

			waitInMilliseconds(500);
		}
		if(vexRT[btn7U] == 1)
		{
			startTask(driveTilt);
			startTask(driveTiltSTRF);
			stopTask(driveJoy);

			waitInMilliseconds(500);
		}
	}
}

task driveJoy()
{
	while(1==1)
	{
		motor[dLF] = vexRT[JOY_LEFT];
		motor[dLR] = vexRT[JOY_LEFT];
		motor[dRF] = vexRT[JOY_RIGHT];
		motor[dRR] = vexRT[JOY_RIGHT];

		int STRFthreshold;				//Threshold value obtained empirically. 36 works best
		STRFthreshold = 36;

		if((vexRT[AccelX] < (-1 * STRFthreshold))) //controller tilted LEFT beyond threshold (NEGATIVE value)
		{
			motor[STRF] = -127;			//LEFT
		}
		else if((vexRT[AccelX] > (STRFthreshold))) //controller tilted RIGHT beyond threshold (POSITIVE value)
		{
			motor[STRF] = 127;			//RIGHT
		}
		else
		{
			motor[STRF] = 0;
		}
	}
}

task driveTilt()
{
	int accel_x   = 0;    				  // Will hold the controller-accelerometer X reading.
	int accel_y   = 0;    				  // Will hold the controller-accelerometer Y reading.

	int prev_x    = 0;     					// Will hold the previous accelerometer X reading (for comparison).
	int prev_y    = 0;    			  	// Will hold the previous accelerometer Y reading (for comparison).

	const int driveScale = (5/3);		// Scale the motor speed

	const int drive_refresh = 10;		// wait # milliseconds to refresh speed values- period

	int threshold = 30;    					// Used to eliminate the effect of small tilt values

	const int speed_limit = 127; 		// Maximum motor speed

	int dLFspeed;
	int dLRspeed;
	int dRFspeed;
	int dRRspeed;

	while(1 == 1)
	{
		prev_x = accel_x;         	  // update previous x reading to 'accel_x'
		prev_y = accel_y;         	  // update previous y reading to 'accel_y'
		accel_x = vexRT[AccelX];   		// update 'accel_x' to new current reading
		accel_y = vexRT[AccelY];    	// update 'accel_y' to new current reading

		// is abs(current - prev) < threshold?
		if( (abs(accel_x - prev_x) < threshold) || (abs(accel_y - prev_y) > threshold) )
		{
			// Are either of them > threshold?
			if( (abs(accel_x) > threshold) || (abs(accel_y) > threshold) )
			{
				// YES.
				if(accel_y > 0)						// going backwards?
				{
					dLFspeed = ( ((-1 * accel_y) - accel_x)/2 ) * (driveScale);
					dLRspeed = ( ((-1 * accel_y) - accel_x)/2 ) * (driveScale);
					dRFspeed = ( ((-1 * accel_y) + accel_x)/2 ) * (driveScale);
					dRRspeed = ( ((-1 * accel_y) + accel_x)/2 ) * (driveScale);
				}
				else  										// going forward, or point turn:
				{
					dLFspeed = ( ((-1 * accel_y) + accel_x)/2 ) * (driveScale);
					dLRspeed = ( ((-1 * accel_y) + accel_x)/2 ) * (driveScale);
					dRFspeed = ( ((-1 * accel_y) - accel_x)/2 ) * (driveScale);
					dRRspeed = ( ((-1 * accel_y) - accel_x)/2 ) * (driveScale);
				}
			}
			else												// If the values are less than the threshold
			{
				dLFspeed = 0;
				dLRspeed = 0;
				dRFspeed = 0;
				dRRspeed = 0;
			}
		}

		//Speed limiter

		if(dLFspeed > speed_limit)
		{
			dLFspeed = speed_limit;
		}
		if(dLRspeed > speed_limit)
		{
			dLRspeed = speed_limit;
		}
		if(dRFspeed > speed_limit)
		{
			dRFspeed = speed_limit;
		}
		if(dRRspeed > speed_limit)
		{
			dRRspeed = speed_limit;
		}

		if(dLFspeed < (-1 * speed_limit))
		{
			dLFspeed = (-1 * speed_limit);
		}
		if(dLRspeed < (-1 * speed_limit))
		{
			dLRspeed = (-1 * speed_limit);
		}
		if(dRFspeed < (-1 * speed_limit))
		{
			dRFspeed = (-1 * speed_limit);
		}
		if(dRRspeed < (-1 * speed_limit))
		{
			dRRspeed = (-1 * speed_limit);
		}

		motor[dLF] = dLFspeed;				// Assign speed values
		motor[dLR] = dLRspeed;
		motor[dRF] = dRFspeed;
		motor[dRR] = dRRspeed;

		wait1Msec( drive_refresh );   // Wait "drive_refresh" ms to refresh speed assignment
	}
}

task driveTiltSTRF()
{
	while(1==1)
	{
		motor[STRF] = vexRT[Ch1];			// While tilt control is active, strafing is controlled by right joystick
	}
}


//*****STRAFE CONTROL*****



void STRFCode()						//BUTTON code
{
	if((vexRT[STRF_LEFT] == 1))
	{
		motor[STRF] = -127;			//LEFT
	}
	else if((vexRT[STRF_RIGHT] == 1))
	{
		motor[STRF] = 127;			//RIGHT
	}
	else
	{
		motor[STRF] = 0;
	}
}



//*****CLAW CONTROL*****
void clawCode()
{
	if((vexRT[Btn5D]==1) && (SensorValue[clawPot] >= 1440)) //OPEN
	{
		motor[CB] = -70;
	}
	else if((vexRT[Btn5U]==1))  //CLOSE
	{
		motor[CB] = 40;
	}
	else if((SensorValue(clawPot) >= 2200) &&	(vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0))
		//If the claw is closed to the value the pot reads when it is clamped on a skyrise (or less),
	{
		motor[CB] = 10;
	}
	else if((SensorValue(clawPot) <= 1800) &&	(SensorValue(clawPot) >= 1440)&&	(vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0))
		//If the claw is open somewhat, apply continunous low power to keep it open
	{
		motor[CB] = -10;
	}
	else
	{
		motor[CB] = 0;
	}
}
