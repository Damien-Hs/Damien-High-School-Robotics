#pragma config(Sensor, in1,    autoPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LENC,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RENC,           sensorQuadEncoder)
#pragma config(Sensor, dgtl12, LED,            sensorLEDtoVCC)
#pragma config(Motor,  port1,           dLR,           tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port2,           dLF,           tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           dRF,           tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port4,           LL1,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           LL2,           tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           LR1,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           LR2,           tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           CB,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           STRF,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          dRR,           tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



/*************************************************************************************************************************************************
PINOUT
**************************************************************************************************************************************************/
/*

Analog
autoPot				autonomous selector potentiometer
liftPot				lift potentiometer
clawPot				claw potentiometer

Digital
LENC					lef encoder, rear wheel
RENC					right encoder, rear wheel

Motors
dLR						drive, left rear motor			3:2			100 rpm
dLF						drive, left front motor			3:2			100 rpm
dRF						drive, right front motor		3:2			100 rpm
LL1						lift, one left motor				5:1			100 rpm								As the lift is synchronized, which lift motor is 1 or 2 does not matter
LL2						lift, one left motor				5:1			100 rpm
LR1						lift, one right motor				5:1			100 rpm
LR2						lift, one right motor				5:1			100 rpm
CB						claw motor									3:1			100 rpm
STRF					strafe wheel motor					1:1			100 rpm
dRR						drive, right rear motor			3:2			100 rpm

*/




/*************************************************************************************************************************************************
CHANGELOG
**************************************************************************************************************************************************/
/*

5603B FINAL		Final 6526D 2014-2015 regular season competition code (24.1.2015, Hesperia, CA)


5603E1 v.1.0	Strafe wheel controls changed from buttons 8L, 8R to remote tilt
5603E1 v.1.1	Organized autonomous code by using functions, deleted bilingual comments, added variable repository, reduced code length
5603E1 v.1.2	Added pinout information. Removed unnecessary autoTester potentiometer


5603E2 v.0.1	Added ezperimental P loop to lift. Claw will now have continuous low power applied when grabbing an object. A second P loop
added to claw, to hold the claw open when desired. Values and constants stored in repository. Lift down speed changed to
-70 msu. Backups of manual (non-P) controls added, in comment form.
5603E2 v.0.3	Organized usercontrol code by functions. Replaced while 1==1 in P loop with do-while(control == 0) It works, but kPs need tuning
5603E2 v.0.4	Added a toggle button(7R) for switching between tilt and button strafe. Does not work
5603E2 v.0.5 	New PID experiment. Reorganized functions.

5603E2 v.1.0	Added first working lift PID, from experimental code. Updated variable repository

*/



/*************************************************************************************************************************************************
VARIABLE REPOSITORY
**************************************************************************************************************************************************/
/*

a( PMA + CB )		autonomous with cube dump procedure (PMA) and cube grab procedure (CB)

<PMA>
forward									45 degE						degrees/encoder
liftup									2180 countP				counts of potentiometer
liftdown								1760 countP
back										-38 degE
turn										200 degE


<CB>
forward									270 degE
turn180									580 degE
forward									90 degE
back										2000 ms


Autonomous selector: located at 0, -90, and -180 deg about potentiometer
500		countP
1900	countP
3500	countP


Normal lift code speeds
up											70 msu							--The msu is a unit representing programmed motor speed
down										-70 msu							Conversion: (motor RPM rating- 100, 160, or 240) x (programmed msu / 127 msu) = (actual motor RPM)
(RPM) x ((2pi rad)/(60 s)) = motor speed (rad/s)


Lift
kP											0.3
kI											0
kD 											0
Lift_Pos_Min						1760 countP
Lift_Pos_Max						3660 countP
PID_INTEGRAL_LIMIT 			50
PID_MOTOR_SCALE					-1
PID_SENSOR_SCALE				1
refresh									5 ms								Interval between each calculation of target value
-												200 Hz
deltaTarget							12 countP 					(per 10 ms)
dT/dt										1200 countP/s				Rate of change of deltaTarget


Tilt Strafe
threshold								36
speed										127 msu


Claw
maximum open						1440 countP 					(range is > 1440)
autoclamp threshold			>= 2200	countP
autoclamp speed					10 msu
autoopen threshold			<= 1800 countP
autoopen speed					10 msu


Lift Data (collected by empirical methods and Sun's Lift Formulas)
ideal height						53.7 in													determined by the Bar Height Formula
actual height						49.5 in													empirically measured
height efficiency				0.93														ratio of actual height to ideal height
--How efficient is the lift in terms of height? (Will never > 1)
ideal speed							36.5 in/s												determined by differential calculus applied to ideal height and angular speed of motor
--What is the ideal vertical speed of the claw, not considering friction and weight?
actual speed (up)				24.75 in/s											actual height divided by time
actual speed(down)			20 in/s (estimated)							actual height divided by time
speed efficiency				0.68														ratio of actual up speed to ideal up speed
--How efficient is the lift in terms of time to rise up?
**This (< 1) means that the lift is not as fast as it can be. Motor speed dows not matter.
G coefficient						1.24 														ratio of actual up speed to actual down speed
--Are rubber bands helping the lift to go up faster than going down?
**This (> 1) means that the lift is going up faster than it is going down.

*/



/*************************************************************************************************************************************************
AUTONOMOUS - DEFINITIONS
**************************************************************************************************************************************************/



/*
8 Autonomi. L for left, R for right.

autoPot LEFT UP					PMA (cube dump and grabbing cube out of square) for BLUE
autoPot LEFT DOWN				cube grab out of square (general, 180 deg turn LEFT)
autoPot RIGHT DOWN			cube grab out of square (general, 180 deg turn RIGHT)
autoPot RIGHT UP. 			PMA for RED = RIGHT)
*/



//*****SIMPLE BEHAVIORS*****

void clear();					//Clear all encoders and sensors

void closeClaw();			//claw close function
void closeClaw1();		//claw close function- longer motor run time
void openClaw();			//claw open function

//*****ROUTINE COMPONENTS*****

void CBLeft();				//Cube grab run (left turn)
void CBRight();				//Cube grab run (right turn)

void PMA();						//Cube dump run

//*****TRANSITIONS*****

void alignLeft();			//for the BLUE <PMA + CB>- Align the robot so that the field perimeter is to its left
void alignRight();		//for the RED <PMA + CB>- Align the robot so that the field perimeter is to its right



/*************************************************************************************************************************************************
PRIMARY AUTONOMOUS FUNCTION
**************************************************************************************************************************************************/



void autoTest()
//This is the autonomous code, used in task autonomous and usercontrol tester for ease of modification
//All previous functions are used in this function
{
	clear();					//Clear encs and timers

	//*****PMA, RED SIDE*****

	if((SensorValue[autoPot] <= 500) && (SensorValue[autoPot] >= 0))
	{
		PMA();					//Run the cube dump function. The following commands transition the robot to proper position for CB.

		alignRight();		//transition to CB position

		CBLeft();				//Run the cube grab function with a left 180deg turn.
	}

	//*****CUBE GRAB, LEFT TURN*****

	if((SensorValue[autoPot] <= 3500) && (SensorValue[autoPot] > 1900))
	{
		CBLeft();				//Run the cube grab function with a left 180deg turn.
	}

	//*****CUBE GRAB, RIGHT TURN*****

	if((SensorValue[autoPot] <= 1900) && (SensorValue[autoPot] > 500))
	{
		CBRight();			//Run the cube grab function with a right 180deg turn.
	}

	//*****PMA, BLUE SIDE*****

	if((SensorValue[autoPot] <= 4095) && (SensorValue[autoPot] > 3500))
	{
		PMA();					//Run the cube dump function. The following commands transition the robot to proper position for CB.

		alignLeft();		//transition to CB position

		CBRight();			//Run the cube grab function with a right 180deg turn.
	}
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////



void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
	clear();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	autoTest();

	//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}



/*************************************************************************************************************************************************
AUTONOMOUS FUNCTIONS- SIMPLE BEHAVIORS
**************************************************************************************************************************************************/



void setDriveSpeed (int dSpeed)
//drive code block
{
	motor[dLF] = dSpeed;
	motor[dLR] = dSpeed;
	motor[dRF] = dSpeed;
	motor[dRR] = dSpeed;
}



void clear()
//Clear encs and timers
{
	SensorValue[dgtl1] = 0;
	SensorValue[dgtl3] = 0;
	clearTimer(T1);
	clearTimer(T2);
	clearTimer(T3);
	clearTimer(T4);
}



void closeClaw()
//close claw function for autonomous
{
	motor[CB] = 60;
	waitInMilliseconds(650);
	motor[CB] = 0;
}



void closeClaw1()
//special closeClaw function, extra long
{
	motor[CB] = 60;
	waitInMilliseconds(850);
	motor[CB] = 0;
}



void openClaw()
//open claw function for autonomous
{
	motor[CB] = -60;
	waitInMilliseconds(900);
	motor[CB] = 0;
}



/*************************************************************************************************************************************************
AUTONOMOUS- ROUTINE COMPONENTS
**************************************************************************************************************************************************/



void CBLeft()
//This is the cube grab run common to both kinds of autonomous. The 180 deg turn is made LEFT
{
	//Robot moves forward for about 13 inches to first cube outside of start square
	setDriveSpeed(127);

	untilEncoderCounts(270, dgtl1);

	setDriveSpeed(0);

	//Release the claw motor (that was held open by the previous PMA function if cube was dumped, or simply does nothing if cube dump was not used)
	motor[CB] = 0;

	//Close claw on cube
	closeClaw();

	//Keep motor running to ensure grip
	motor[CB] = 20;

	//Robot makes 180 deg point turn LEFT using the right enc to navigate
	SensorValue[dgtl3] = 0;

	motor[dLF] = -127;
	motor[dLR] = -127;
	motor[dRF] = 127;
	motor[dRR] = 127;

	untilEncoderCounts(580, dgtl3);

	//Robot returns to starting square
	SensorValue[dgtl1] = 0;
	SensorValue[dgtl3] = 0;

	setDriveSpeed(127);

	untilEncoderCounts(90, dgtl1);

	setDriveSpeed(0);

	//Releases claw motor to prepare for opening claw
	motor[CB] = 0;

	//Open claw to release cube
	openClaw();

	//Back away for 2 s
	setDriveSpeed(-127);

	waitInMilliseconds(2000);

	setDriveSpeed(0);

	//END- clear encs
	clear();
}



void CBRight()
//This is the cube grab run common to both kinds of autonomous. The 180 deg turn is made RIGHT
{
	//Robot moves forward for about 13 inches to first cube outside of start square
	setDriveSpeed(127);

	untilEncoderCounts(270, dgtl1);

	setDriveSpeed(0);

	//Release the claw motor (that was held open by the previous PMA function if cube was dumped, or simply does nothing if cube dump was not used)
	motor[CB] = 0;

	//Close claw on cube
	closeClaw1();

	//Keep motor running to ensure grip
	motor[CB] = 20;

	//Robot makes 180 deg point turn RIGHT using the left enc to navigate
	SensorValue[dgtl1] = 0;

	motor[dLF] = 127;
	motor[dLR] = 127;
	motor[dRF] = -127;
	motor[dRR] = -127;

	untilEncoderCounts(580, dgtl1);

	//Robot returns to starting square
	SensorValue[dgtl1] = 0;
	SensorValue[dgtl3] = 0;

	setDriveSpeed(127);

	untilEncoderCounts(90, dgtl1);

	setDriveSpeed(0);

	//Releases claw motor to prepare for opening claw
	motor[CB] = 0;

	//Open claw to release cube
	openClaw();

	//Back away for 2 s
	setDriveSpeed(-127);

	waitInMilliseconds(2000);

	setDriveSpeed(0);

	//END, clear ENCs
	clear();
}



void PMA()
//This is the cube dump function that is used to score one cube on the low post at the corner of the non-skyrise start square
//Robot must be set up with the cube on the dump rack, 45 degrees to the arena wall, with rear as close to the corner of
//the start square as possible

//This autonomous behavior is identical for both RED and BLUE
{
	int PMAWaitTime;		//This is currently useless; is not read by the code for unknown reasons.
	//It was intended to keep the lift at the dump position for 200 ms
	PMAWaitTime = 200;

	//Close claw so lift can rise
	closeClaw1();

	//move forward to proper dump position
	setDriveSpeed(127);

	untilEncoderCounts(45,dgtl1);

	setDriveSpeed(0);

	waitInMilliseconds(200);

	//raise lift
	motor[LL1] = 127;
	motor[LL2] = 127;
	motor[LR1] = 127;
	motor[LR2] = 127;

	//stop at this angular position (approx -20 degrees when origin when lift segments are parallel to each other)
	untilPotentiometerGreaterThan(2180, in2);

	motor[LL1] = 0;
	motor[LL2] = 0;
	motor[LR1] = 0;
	motor[LR2] = 0;

	waitInMilliseconds(PMAWaitTime);

	//drop lift
	motor[LL1] = -127;
	motor[LL2] = -127;
	motor[LR1] = -127;
	motor[LR2] = -127;

	untilPotentiometerLessThan(1760, in2);

	//force lift down for an extra 500 ms to ensure that the rubber bands will not force lift to jump up slightly
	waitInMilliseconds(500);

	motor[LL1] = 0;
	motor[LL2] = 0;
	motor[LR1] = 0;
	motor[LR2] = 0;

	//Robot returns to origin
	setDriveSpeed(-127);

	SensorValue(dgtl1)= 0;
	untilEncoderCounts(-38, dgtl1);
	SensorValue(dgtl1)= 0;

	setDriveSpeed(0);

	//open and keep claw open to ensure that the claw is open for grabbing
	openClaw();

	motor[CB] = -15;
}



/*************************************************************************************************************************************************
AUTONOMOUS - ROUTINE TRANSITIONS
**************************************************************************************************************************************************/



void alignLeft()
//The transition from PMA to CBRight of the BLUE side <PMA + CB>
{
	//TURN LEFT 45 deg so robot is parallel to adjacent field perimeter to prepare for cube grab
	SensorValue[dgtl3] = 0;

	motor[dRF] = 127;
	motor[dRR] = 127;

	untilEncoderCounts(200, dgtl3);
	SensorValue[dgtl3] = 0;

	//The perimeter is now at the LEFT of the bot
}



void alignRight()
//The transition from PMA to CBLeft of the RED side <PMA + CB>
{
	//TURN RIGHT 45 deg so robot is parallel to adjacent field perimeter to prepare for cube grab
	SensorValue[dgtl1] = 0;

	motor[dLF] = 127;
	motor[dLR] = 127;

	untilEncoderCounts(200, dgtl1);

	SensorValue[dgtl1] = 0;

	//The perimeter is now at the RIGHT of the bot
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////



/*************************************************************************************************************************************************
DRIVER CONTROL - DEFIITIONS
**************************************************************************************************************************************************/



void autoTester();			//Autonomous tester code call function

void driveCode();				//Primary drive code

task tiltSTRF();				//Tilt strafe code
task buttonSTRF();			//Button strafe code
task STRFControl();			//Control stucture (toggle) for strafe
task STRFCode();				//Task control (which task is on/off) for strafe

void STRFTiltOnly();		//Backup tilt-only code

task liftPID();					//Lift manual PID control			modifies motor speed
task LPIDControl();			//Joystick control						modifies target value

void clawCode();				//claw code



/*************************************************************************************************************************************************
DRIVER CONTROL AUTOMATIC LIFT CONTROL (ALC) DEFINITIONS
**************************************************************************************************************************************************/


/*
task ACL();							//Primary ACL control structure
task lowPOS();					//Automatic raise to low post position
task maxPOS();					//Automatic raise to maximum position
void autoLift();				//Allows a parametic function setup

int Low_Pos = 2500;			//target values (potentiometer values) for low and medium posts
int High_Pos = 3650;
*/


/*************************************************************************************************************************************************
LIFT PID- MANUAL- DEFINITIONS
**************************************************************************************************************************************************/



#define PID_SENSOR_INDEX    liftPot				//Lift potentiometer
#define PID_SENSOR_SCALE    (1)

void LPID (float LPIDSpeed)
{
	motor[LL1] = LPIDSpeed;
	motor[LL2] = LPIDSpeed;
	motor[LR1] = LPIDSpeed;
	motor[LR2] = LPIDSpeed;
}

#define Lift_Pos_Max				(1900)				// = 3660 reading
#define Lift_Pos_Min				(0)						// = 1760 reading

#define PID_MOTOR_SCALE     (-1)					// -1 necessary to ensure exponential decay and not growth


#define PID_SPEED_MAX       127						//Minimum and maximum motor speeds
#define PID_SPEED_MIN     (-127)

#define PID_INTEGRAL_LIMIT  50

// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float  pid_Kp = 0.3;
float  pid_Ki = 0.0;
float  pid_Kd = 0.0;

static int   pidRunning = 1;
static float pidTargetL;		//Target value



/*************************************************************************************************************************************************
DRIVER CONTROL PRIMARY TASK
**************************************************************************************************************************************************/



task usercontrol()
{
	clear();																							//clear encs and timers

	/*
	startTask (STRFControl);															//start strafe toggle and driving tasks
	startTask (STRFCode);
	*/

	startTask (LPIDControl);															//Start the main PID control task, which will start the PID speed calculation task

	while (1==1)
	{
		autoTester();																				//Start normal driving functions
		driveCode();
		clawCode();

		STRFTiltOnly();																			//Backup tilt-only function, comment out if necessary
	}
	//UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
}



/***************************************************************************************************************************************************
LIFT MANUAL PID
****************************************************************************************************************************************************/



//*****PID TASK*****
//This will be called out by the control task
task liftPID()
{
	float  pidSensorCurrentValue;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidSpeed;

	// Init the variables - thanks Glenn :)
	pidLastError  = 0;
	pidIntegral   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = (SensorValue[ PID_SENSOR_INDEX ] - 1760) * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - pidTargetL;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidSpeed = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidSpeed > PID_SPEED_MAX )
			{
				pidSpeed = PID_SPEED_MAX;
			}
			if( pidSpeed < PID_SPEED_MIN )
			{
				pidSpeed = PID_SPEED_MIN;
			}

			// send to motor
			LPID((pidSpeed * PID_MOTOR_SCALE));
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			LPID(0);
		}

		wait1Msec( 5 );					//Wait 5 ms to refresh this calculation = 200 Hz
	}
}



//*****PID CONTROL TASK*****
task LPIDControl()
{
	// initialize PID at the current senor value when robot is turned on

	//		 0 <= pidTargetL <= 1900		=		1760 <= SensorValue(liftPot) <= 3660
	//			pidTargetL is zeroed at angular position 1760 countP (Lift_Pos_Min)

	pidTargetL = ((SensorValue[ PID_SENSOR_INDEX ] - (1760)) * (PID_SENSOR_SCALE));

	// start the PID task
	startTask( liftPID );

	float deltaTarget = 12;

	// use buttons to modify the requested position
	while( 1==1 )
	{
		// original value: 127/4 = 640 counts/s
		// free spinning motor is 100rpm = 1.67 s^-1
		// 1.67 * 360 counts is 600 deg/s

		// current dTarget/dt is 12 countP / 10 ms

		if((vexRT[Btn6U] == 1))
		{
			pidTargetL = pidTargetL + (deltaTarget);
		}
		if((vexRT[Btn6D] == 1))
		{
			pidTargetL = pidTargetL - (deltaTarget);
		}

		if( (pidTargetL) > (Lift_Pos_Max) )
		{
			pidTargetL = Lift_Pos_Max;
		}
		if( (pidTargetL) < (Lift_Pos_Min) )
		{
			pidTargetL = Lift_Pos_Min;
		}

		wait1Msec(10);					//Wait 10 ms to refresh = 100 s^-1 , or 1200 countP / s
	}
}



/*************************************************************************************************************************************************
DRIVER CONTROL FUNCTIONS
**************************************************************************************************************************************************/



//*****AUTONOMOUS TESTER IN DRIVER CONTROL*****
void autoTester()
{
	//Autonomous Code Tester activated by btn7L
	//COMMENT OUT BEFORE MATCH

	/**/
	if(vexRT[Btn7L] == 1)
	{
		autoTest();
	}
	/**/
}



//*****CHASSIS CONTROL*****
void driveCode()
{
	motor[dLF] = vexRT[Ch3];
	motor[dLR] = vexRT[Ch3];
	motor[dRF] = vexRT[Ch2];
	motor[dRR] = vexRT[Ch2];
}



//*****STRAFE CONTROL*****

//TASKS

task tiltSTRF()						//TILT code
{
	int STRFthreshold;				//Threshold value obtained empirically. 36 works best
	STRFthreshold = 36;

	if((vexRT[AccelX] < (-1 * STRFthreshold))) //controller tilted LEFT beyond threshold (NEGATIVE value)
	{
		motor[STRF] = -127;			//LEFT
	}
	else if((vexRT[AccelX] > (STRFthreshold))) //controller tilted RIGHT beyond threshold (POSITIVE value)
	{
		motor[STRF] = 127;			//RIGHT
	}
	else
	{
		motor[STRF] = 0;
	}
}



task buttonSTRF()						//BUTTON code
{
	if((vexRT[Btn8L] == 1))
	{
		motor[STRF] = -127;			//LEFT
	}
	else if((vexRT[Btn8R] == 1))
	{
		motor[STRF] = 127;			//RIGHT
	}
	else
	{
		motor[STRF] = 0;
	}
}


//CONTROL STRUCURE
/*
bool toggle= false;									//Control variable "toggle" = true/false- TRUE = tilt; FALSE = button
//																	//Toggle controlled by btn7R

task STRFControl()
{
//TOGGLE CONTROL STRUCTURE
while(1==1)
{
if((vexRT[btn7R] == 1) && (toggle == false))
{
toggle = true;								//set true
turnLEDOn(LED);								//Turn on indicator LED
waitInMilliseconds(300);			//Wait to prevent instananeous oscillation
}
if((vexRT[btn7D] == 1) && (toggle == true))
{
toggle = false;								//set  false
turnLEDOff(LED);							//Turn off indicator LED
waitInMilliseconds(300);			//Wait to prevent instananeous oscillation
}
}
}



task STRFCode()
{
while(1==1)
{
if(toggle == true)
{
startTask (tiltSTRF);
stopTask (buttonSTRF);
}
if(toggle == false)
{
startTask (buttonSTRF);
stopTask (tiltSTRF);
}
}
}
*/

//Temporary strafe-only function- insert in usercontrol if desired.

void STRFTiltOnly()
{
	startTask(tiltSTRF);
}


//*****CLAW CONTROL*****
void clawCode()
{
	if((vexRT[Btn5D]==1) && (SensorValue[clawPot] >= 1440)) //OPEN
	{
		motor[CB] = -70;
	}
	else if((vexRT[Btn5U]==1))  //CLOSE
	{
		motor[CB] = 40;
	}

	//OPTION A- Power applied when the potentiometer value is within the "grabbing range"- Comment out if necessary
	/**/
	else if((SensorValue(clawPot) >= 2200) &&	(vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0))
		//If the claw is closed to the value the pot reads when it is clamped on a skyrise (or less),
	{
		motor[CB] = 10;
	}
	else if((SensorValue(clawPot) <= 1800) &&	(SensorValue(clawPot) >= 1440))
		//If the claw is open somewhat, apply continunous low power to keep it open
	{
		motor[CB] = -10;
	}
	else
	{
		motor[CB] = 0;
	}
	/**/

	//OPTION C- Power applied when the potentiometer value is within the "grabbing range" AND P loop to hold claw open
	/*

	//**AUTOMATIC CLAMP**
	else if(SensorValue(clawPot) >= 2200 && (vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0))
	//TEST THIS VALUE MANUALLY
	//If the claw is closed to the value the pot reads when it is clamped on a skyrise (or less),
	{
	motor[CB] = 8;																	//Apply a continuous low power to keep object gripped
	}

	//**CLAW P LOOP*																	Apply power to keep claw open (resist tension of rubber band)
	else if((SensorValue(clawPot) >= 1440) && (SensorValue(clawPot) <= 1800) && (vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0))
	//if the claw is open (pot reading a certain range) and there is no power applied to the claw motor,
	{
	float kPCB;
	kPCB = 0.06;																			//Proportionality constant- TEST BY TRIAL/ERROR

	int targetCB;
	targetCB = SensorValue(clawPot);								//Calculate target value- where the claw should be at

	//The target should only be calculated once, when all rc input ceases and the claw is open

	do
	{
	float errorCB;
	errorCB = (targetCB - SensorValue(clawPot));	//Compute an error value
	//The speed applied to the lift motors will be directly proportional to this error by constant kPCB

	if(errorCB > 10)															//If error greater than some substantial value
	{
	motor[CB] = ceil(kPCB * errorCB * (-1));		//Motor speed is proportional to the error
	//"ceil" = smallest interger larger than. Prevents decimal motor speed assignment

	//If the error is small and kPCB * error is a decimal (-1,0), the motor speed will be zero to prevent stress
	//OPEN motor velocity is negative, therefore -1 is needed
	}
	else																					//If the error is negligible, apply no power
	{
	motor[CB] = 0;
	}
	}
	while((vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0) && (SensorValue(clawPot) >= 1440));
	}
	else																							//End of the if-ifelse-else claw control structure. This will NEVER be active
	{
	motor[CB] = 0;
	}
	*/
}



/***************************************************************************************************************************************************
ALC TASKS- NOT FINISHED
****************************************************************************************************************************************************/


/*
void autoLift (float targetLA)		//PID CODE GOES HERE
{

}



//***Positional Tasks***
//These call the ACL function to a certain potentiometer value

task lowPOS
{
autoLift(2300);
}

task maxPOS
{
autoLift(3660);
}
*/
