//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//***************************************************************************************
//														Damien Robotics Academy
//																Code Template
//***************************************************************************************

/*
Team:							6526D
Robot:						N/A
Code:							Lift Manual PID Control Template
Programmer:				Ray Sun
Conception Date: 	3/13/2015
Purpose:					Template for manual PID control of a lift mechanism

Code Version:			v.1.0
Status:						Operational
Date:							3/13/2015

NOTE: This code was designed for use with a potentiometer. Computations of the target values
reflect such an approach.
*/

/////////////////////////////////////////////////////////////////////////////////////////
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
/////////////////////////////////////////////////////////////////////////////////////////

//*****DEFINITIONS******

#define PID_SENSOR_INDEX    liftPot						// Specify the lift sensor
#define PID_SENSOR_SCALE    (1)								// Scale the sensor value if necessary by multiplying by a constant
#define PID_SENSOR_DISP			(-1760)						// Shift the sensor values (if using a potentiometer) so that "zero" is another value

void LPID (float LPIDSpeed)										// Function to assign a speed "LPIDSpeed" to lift motors
{																							// This will be used to set all lift motors' speed equal to the calculated PID speed
	motor[LL1] = LPIDSpeed;											// Add, remove, or rename lift motors as necessary
	motor[LL2] = LPIDSpeed;
	motor[LR1] = LPIDSpeed;
	motor[LR2] = LPIDSpeed;
}

#define LIFT_UP_BUTTON			btn6U							// Specify which buttons are used to raise and lower lift
#define LIFT_DOWN_BUTTON		btn6D

#define Lift_Pos_Max				(1900)						// Define maximum and minimum position values
#define Lift_Pos_Min				(0)								// THESE VALUES REFLECT DISPLACEMENT AND SCALING
																							// Calculate these values manually

#define PID_MOTOR_SCALE     (-1)							// Modify to scale the motor speed. MUST BE NEGATIVE

#define PID_SPEED_MAX       127								// Define maximum and minimum motor speeds
#define PID_SPEED_MIN     (-127)

#define PID_INTEGRAL_LIMIT  (50)							// Define a limit that eror values less than or equal to it will be integrated.

#define SPEED_REFRESH_RATE	(5)								// Define the rate at which the speed calculation repeats (period), in ms

#define DELTA_TARGET				(12)							// Define how much the target value changes per cycle of the control task
#define TARGET_REFRESH_RATE	(10)							// Define the rate at which the target value calculation repeats (period), in ms

// Define constants
float  pid_Kp = 0.3;
float  pid_Ki = 0.0;
float  pid_Kd = 0.0;

static int   pidRunning = 1;									// Variable to indicate whether PUD os activated or not
static float pidTargetL;											// Target value

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*  pid control task                                                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/



//***** SPEED CALCULATION *****

//Insert this task near the driver control code. It will be called  by the target calculation task.
task LiftPID()
{
	float  pidSensorCurrentValue;

	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidSpeed;

	// Initialize the variables at 0
	pidLastError  = 0;
	pidIntegral   = 0;

	while( true )
	{
		// Is PID control active ?
		if( pidRunning )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = (SensorValue[ PID_SENSOR_INDEX ] - 1760) * PID_SENSOR_SCALE;

			// calculate error
			pidError = pidSensorCurrentValue - pidTargetL;

			// integral - if Ki is not 0
			if( pid_Ki != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidSpeed = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

			// limit drive
			if( pidSpeed > PID_SPEED_MAX )
			{
				pidSpeed = PID_SPEED_MAX;
			}
			if( pidSpeed < PID_SPEED_MIN )
			{
				pidSpeed = PID_SPEED_MIN;
			}

			// send to motor
			LPID((pidSpeed * PID_MOTOR_SCALE));
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			LPID(0);
		}

		wait1Msec( SPEED_REFRESH_RATE );
	}
}



//***** TARGET CALCULATION *****

// Insert this function near the driver control code. It will be called  by the main usercontrol task
task LPIDControl()
{
	// initialize target at the current senor value when robot is turned on, accounting for displacement and scale

	pidTargetL = ((SensorValue[ PID_SENSOR_INDEX ] + ( PID_SENSOR_DISP )) * (PID_SENSOR_SCALE));

	// start the PID speed calculation task
	startTask( LiftPID );

	float deltaTarget = DELTA_TARGET;

	// use buttons to modify the requested position- pidTargetL
	while( 1==1 )
	{
		// original value: 127/4 = 640 counts/s
		// free spinning motor is 100rpm = 1.67 s^-1
		// 1.67 * 360 counts is 600 deg/s
		// 600 deg/s = 9100 degP/s

		if((vexRT[ UP_BUTTON ] == 1))
		{
			pidTargetL = pidTargetL + (deltaTarget);
		}
		if((vexRT[ DOWN_BUTTON ] == 1))
		{
			pidTargetL = pidTargetL - (deltaTarget);
		}

		if( (pidTargetL) > (Lift_Pos_Max) )
		{
			pidTargetL = Lift_Pos_Max;
		}
		if( (pidTargetL) < (Lift_Pos_Min) )
		{
			pidTargetL = Lift_Pos_Min;
		}

		wait1Msec( TARGET_REFRESH_RATE );					//Wait to refresh
	}
}



//***** MAIN CODE *****



task usercontrol()
{
	// Insert other driver control code here

	startTask(LPIDControl);			// Start the PID tasks
}
